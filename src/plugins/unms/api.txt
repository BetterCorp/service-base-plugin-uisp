/**
 * UNMS API
 * You can authorize calls with x-auth-token by clicking the button on the right, to not have to fill in authorization token for each request. Entered value in authorization token for a request, will be replaced by the one entered in authorization. To get this token use /user/login request.
 *
 * OpenAPI spec version: 
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');

let defaultBasePath = 'https://localhost/v2.1';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

export class AirCubeNetworkConfig {
    /**
    * Network mode
    */
    'mode'?: any;
    'blockManagementAccess'?: boolean;
    'lan'?: any;
    'wan'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "mode",
            "baseName": "mode",
            "type": "any"
        },
        {
            "name": "blockManagementAccess",
            "baseName": "blockManagementAccess",
            "type": "boolean"
        },
        {
            "name": "lan",
            "baseName": "lan",
            "type": "any"
        },
        {
            "name": "wan",
            "baseName": "wan",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return AirCubeNetworkConfig.attributeTypeMap;
    }
}

/**
* Read-only AirCube detail
*/
export class AirCubeStatusDetail {
    'identification'?: DeviceIdentification;
    'overview'?: DeviceOverview;
    'firmware'?: DeviceFirmware;
    'upgrade'?: DeviceUpgradeStatus;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "identification",
            "baseName": "identification",
            "type": "DeviceIdentification"
        },
        {
            "name": "overview",
            "baseName": "overview",
            "type": "DeviceOverview"
        },
        {
            "name": "firmware",
            "baseName": "firmware",
            "type": "DeviceFirmware"
        },
        {
            "name": "upgrade",
            "baseName": "upgrade",
            "type": "DeviceUpgradeStatus"
        }    ];

    static getAttributeTypeMap() {
        return AirCubeStatusDetail.attributeTypeMap;
    }
}

export class AirCubeSystemConfig {
    /**
    * Device hostname
    */
    'deviceName'?: string;
    /**
    * OpenWrt timezone, e.g. 'CET-1CEST,M3.5.0,M10.5.0/3'
    */
    'timezone'?: string;
    /**
    * OpenWrt zonename, e.g. 'Europe/Prague'
    */
    'zonename'?: string;
    'username'?: string;
    'newPassword'?: string;
    'ledNightMode'?: any;
    'poePassthrough'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "deviceName",
            "baseName": "deviceName",
            "type": "string"
        },
        {
            "name": "timezone",
            "baseName": "timezone",
            "type": "string"
        },
        {
            "name": "zonename",
            "baseName": "zonename",
            "type": "string"
        },
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        },
        {
            "name": "newPassword",
            "baseName": "newPassword",
            "type": "string"
        },
        {
            "name": "ledNightMode",
            "baseName": "ledNightMode",
            "type": "any"
        },
        {
            "name": "poePassthrough",
            "baseName": "poePassthrough",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return AirCubeSystemConfig.attributeTypeMap;
    }
}

export class AirCubeWirelessConfig {
    'authentication'?: any;
    'available'?: boolean;
    'channel'?: number;
    'country'?: string;
    'encryption'?: any;
    'frequency'?: number;
    'isChannelAuto'?: boolean;
    'isWPA2PSKEnabled'?: boolean;
    /**
    * wireless password
    */
    'key'?: string;
    'mac'?: string;
    'mode'?: any;
    'ssid'?: string;
    'txPower'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "authentication",
            "baseName": "authentication",
            "type": "any"
        },
        {
            "name": "available",
            "baseName": "available",
            "type": "boolean"
        },
        {
            "name": "channel",
            "baseName": "channel",
            "type": "number"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "encryption",
            "baseName": "encryption",
            "type": "any"
        },
        {
            "name": "frequency",
            "baseName": "frequency",
            "type": "number"
        },
        {
            "name": "isChannelAuto",
            "baseName": "isChannelAuto",
            "type": "boolean"
        },
        {
            "name": "isWPA2PSKEnabled",
            "baseName": "isWPA2PSKEnabled",
            "type": "boolean"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "mac",
            "baseName": "mac",
            "type": "string"
        },
        {
            "name": "mode",
            "baseName": "mode",
            "type": "any"
        },
        {
            "name": "ssid",
            "baseName": "ssid",
            "type": "string"
        },
        {
            "name": "txPower",
            "baseName": "txPower",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return AirCubeWirelessConfig.attributeTypeMap;
    }
}

/**
* Read-only AirMax detail
*/
export class AirMaxStatusDetail {
    'identification'?: DeviceIdentification;
    'overview'?: DeviceOverview;
    'firmware'?: DeviceFirmware;
    'upgrade'?: DeviceUpgradeStatus;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "identification",
            "baseName": "identification",
            "type": "DeviceIdentification"
        },
        {
            "name": "overview",
            "baseName": "overview",
            "type": "DeviceOverview"
        },
        {
            "name": "firmware",
            "baseName": "firmware",
            "type": "DeviceFirmware"
        },
        {
            "name": "upgrade",
            "baseName": "upgrade",
            "type": "DeviceUpgradeStatus"
        }    ];

    static getAttributeTypeMap() {
        return AirMaxStatusDetail.attributeTypeMap;
    }
}

export class DHCPLease {
    /**
    * unique per dhcp server
    */
    'leaseId'?: string;
    'type'?: DHCPLease.TypeEnum;
    /**
    * ip address
    */
    'address'?: string;
    'mac'?: string;
    /**
    * expiration date in ISO format (UNMS-420); nullable string
    */
    'expiration'?: string;
    /**
    * nullable string
    */
    'hostname'?: string;
    'serverName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "leaseId",
            "baseName": "leaseId",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "DHCPLease.TypeEnum"
        },
        {
            "name": "address",
            "baseName": "address",
            "type": "string"
        },
        {
            "name": "mac",
            "baseName": "mac",
            "type": "string"
        },
        {
            "name": "expiration",
            "baseName": "expiration",
            "type": "string"
        },
        {
            "name": "hostname",
            "baseName": "hostname",
            "type": "string"
        },
        {
            "name": "serverName",
            "baseName": "serverName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DHCPLease.attributeTypeMap;
    }
}

export namespace DHCPLease {
    export enum TypeEnum {
        Dynamic = <any> 'dynamic',
        Static = <any> 'static'
    }
}
export class DHCPServerConfiguration {
    'name'?: string;
    /**
    * network cidr (192.168.100.0/24)
    */
    '_interface'?: string;
    /**
    * ip address
    */
    'rangeStart'?: string;
    /**
    * ip address
    */
    'rangeEnd'?: string;
    /**
    * ip address
    */
    'router'?: string;
    /**
    * ip address
    */
    'dns1'?: string;
    /**
    * ip address
    */
    'dns2'?: string;
    /**
    * ms
    */
    'leaseTime'?: number;
    /**
    * IPv4 address
    */
    'unifiController'?: string;
    'domain'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "_interface",
            "baseName": "interface",
            "type": "string"
        },
        {
            "name": "rangeStart",
            "baseName": "rangeStart",
            "type": "string"
        },
        {
            "name": "rangeEnd",
            "baseName": "rangeEnd",
            "type": "string"
        },
        {
            "name": "router",
            "baseName": "router",
            "type": "string"
        },
        {
            "name": "dns1",
            "baseName": "dns1",
            "type": "string"
        },
        {
            "name": "dns2",
            "baseName": "dns2",
            "type": "string"
        },
        {
            "name": "leaseTime",
            "baseName": "leaseTime",
            "type": "number"
        },
        {
            "name": "unifiController",
            "baseName": "unifiController",
            "type": "string"
        },
        {
            "name": "domain",
            "baseName": "domain",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DHCPServerConfiguration.attributeTypeMap;
    }
}

/**
* Access points connection profiles
*/
export class DeviceAPSProfile {
    'device'?: DeviceIdentification;
    'mac'?: string;
    'ssid'?: string;
    'key'?: string;
    'countryCode'?: number;
    'channelWidth'?: number;
    'frequency'?: number;
    'security'?: DeviceAPSProfile.SecurityEnum;
    'authentication'?: DeviceAPSProfile.AuthenticationEnum;
    'latitude'?: number;
    'longitude'?: number;
    'airFiber'?: any;
    'airMax'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "device",
            "baseName": "device",
            "type": "DeviceIdentification"
        },
        {
            "name": "mac",
            "baseName": "mac",
            "type": "string"
        },
        {
            "name": "ssid",
            "baseName": "ssid",
            "type": "string"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "countryCode",
            "baseName": "countryCode",
            "type": "number"
        },
        {
            "name": "channelWidth",
            "baseName": "channelWidth",
            "type": "number"
        },
        {
            "name": "frequency",
            "baseName": "frequency",
            "type": "number"
        },
        {
            "name": "security",
            "baseName": "security",
            "type": "DeviceAPSProfile.SecurityEnum"
        },
        {
            "name": "authentication",
            "baseName": "authentication",
            "type": "DeviceAPSProfile.AuthenticationEnum"
        },
        {
            "name": "latitude",
            "baseName": "latitude",
            "type": "number"
        },
        {
            "name": "longitude",
            "baseName": "longitude",
            "type": "number"
        },
        {
            "name": "airFiber",
            "baseName": "airFiber",
            "type": "any"
        },
        {
            "name": "airMax",
            "baseName": "airMax",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return DeviceAPSProfile.attributeTypeMap;
    }
}

export namespace DeviceAPSProfile {
    export enum SecurityEnum {
        WEP = <any> 'WEP',
        WPA = <any> 'WPA',
        WPA2 = <any> 'WPA2',
        None = <any> 'None'
    }
    export enum AuthenticationEnum {
        Psk = <any> 'psk',
        Psk2 = <any> 'psk2',
        Ent = <any> 'ent',
        None = <any> 'none'
    }
}
export class DeviceBackup {
    'id'?: string;
    'timestamp'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "timestamp",
            "baseName": "timestamp",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DeviceBackup.attributeTypeMap;
    }
}

export class DeviceFirmware {
    /**
    * Current firmware version
    */
    'current'?: string;
    /**
    * Latest known firmware version
    */
    'latest'?: string;
    'semver'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "current",
            "baseName": "current",
            "type": "string"
        },
        {
            "name": "latest",
            "baseName": "latest",
            "type": "string"
        },
        {
            "name": "semver",
            "baseName": "semver",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return DeviceFirmware.attributeTypeMap;
    }
}

/**
* read-only identification attributes
*/
export class DeviceIdentification {
    /**
    * device is added to nms
    */
    'authorized'?: boolean;
    'category'?: DeviceIdentification.CategoryEnum;
    /**
    * UNMS device alias or real name
    */
    'displayName'?: string;
    /**
    * semver
    */
    'firmwareVersion'?: string;
    /**
    * technical ID only for NMS
    */
    'id'?: string;
    'mac'?: string;
    /**
    * short names, for example UF-OLT
    */
    'model'?: string;
    /**
    * full names, for example UFiber OLT
    */
    'modelName'?: string;
    'name'?: string;
    /**
    * short name, for example e600
    */
    'platformId'?: string;
    'serialNumber'?: string;
    'site'?: any;
    'type'?: DeviceIdentification.TypeEnum;
    'updated'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "authorized",
            "baseName": "authorized",
            "type": "boolean"
        },
        {
            "name": "category",
            "baseName": "category",
            "type": "DeviceIdentification.CategoryEnum"
        },
        {
            "name": "displayName",
            "baseName": "displayName",
            "type": "string"
        },
        {
            "name": "firmwareVersion",
            "baseName": "firmwareVersion",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "mac",
            "baseName": "mac",
            "type": "string"
        },
        {
            "name": "model",
            "baseName": "model",
            "type": "string"
        },
        {
            "name": "modelName",
            "baseName": "modelName",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "platformId",
            "baseName": "platformId",
            "type": "string"
        },
        {
            "name": "serialNumber",
            "baseName": "serialNumber",
            "type": "string"
        },
        {
            "name": "site",
            "baseName": "site",
            "type": "any"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "DeviceIdentification.TypeEnum"
        },
        {
            "name": "updated",
            "baseName": "updated",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return DeviceIdentification.attributeTypeMap;
    }
}

export namespace DeviceIdentification {
    export enum CategoryEnum {
        Optical = <any> 'optical',
        Wired = <any> 'wired',
        Wireless = <any> 'wireless',
        Accessories = <any> 'accessories'
    }
    export enum TypeEnum {
        Onu = <any> 'onu',
        Olt = <any> 'olt',
        Erouter = <any> 'erouter',
        Eswitch = <any> 'eswitch',
        Epower = <any> 'epower',
        AirCube = <any> 'airCube',
        AirMax = <any> 'airMax',
        AirFiber = <any> 'airFiber',
        ToughSwitch = <any> 'toughSwitch'
    }
}
/**
* Read-only basic device/client overview attributes
*/
export class DeviceOverview {
    /**
    * Read-only value generated by NMS - it is not part of GET_STATUS response
    */
    'status'?: DeviceOverview.StatusEnum;
    /**
    * Uptime in seconds
    */
    'uptime'?: number;
    /**
    * Last seen timestamp
    */
    'lastSeen'?: number;
    /**
    * Current cpu load
    */
    'cpu'?: number;
    /**
    * Current memory usage
    */
    'ram'?: number;
    /**
    * Nullable prop; current signal level (only for airmax devices), for example 55 dBm
    */
    'signal'?: number;
    /**
    * True if device is in location mode
    */
    'locating'?: boolean;
    /**
    * True if device can be upgraded
    */
    'canUpgrade'?: boolean;
    /**
    * System input voltage in V
    */
    'voltage'?: number;
    'temps'?: Array<any>;
    /**
    * nullable property; in meters
    */
    'distance'?: number;
    /**
    * nullable property; in dBm
    */
    'transmitPower'?: number;
    /**
    * nullable property; in dBm
    */
    'receivePower'?: number;
    /**
    * nullable property in milli Ampers
    */
    'biasCurrent'?: number;
    /**
    * nullable property; in bps
    */
    'rxRate'?: number;
    /**
    * nullable property; in Bytes
    */
    'rxBytes'?: number;
    /**
    * nullable property; in bps
    */
    'txRate'?: number;
    /**
    * nullable property; in Bytes
    */
    'txBytes'?: number;
    /**
    * nullable property
    */
    'txDropped'?: number;
    /**
    * nullable property
    */
    'txErrors'?: number;
    /**
    * nullable property
    */
    'rxDropped'?: number;
    /**
    * nullable property
    */
    'rxErrors'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "DeviceOverview.StatusEnum"
        },
        {
            "name": "uptime",
            "baseName": "uptime",
            "type": "number"
        },
        {
            "name": "lastSeen",
            "baseName": "lastSeen",
            "type": "number"
        },
        {
            "name": "cpu",
            "baseName": "cpu",
            "type": "number"
        },
        {
            "name": "ram",
            "baseName": "ram",
            "type": "number"
        },
        {
            "name": "signal",
            "baseName": "signal",
            "type": "number"
        },
        {
            "name": "locating",
            "baseName": "locating",
            "type": "boolean"
        },
        {
            "name": "canUpgrade",
            "baseName": "canUpgrade",
            "type": "boolean"
        },
        {
            "name": "voltage",
            "baseName": "voltage",
            "type": "number"
        },
        {
            "name": "temps",
            "baseName": "temps",
            "type": "Array<any>"
        },
        {
            "name": "distance",
            "baseName": "distance",
            "type": "number"
        },
        {
            "name": "transmitPower",
            "baseName": "transmitPower",
            "type": "number"
        },
        {
            "name": "receivePower",
            "baseName": "receivePower",
            "type": "number"
        },
        {
            "name": "biasCurrent",
            "baseName": "biasCurrent",
            "type": "number"
        },
        {
            "name": "rxRate",
            "baseName": "rxRate",
            "type": "number"
        },
        {
            "name": "rxBytes",
            "baseName": "rxBytes",
            "type": "number"
        },
        {
            "name": "txRate",
            "baseName": "txRate",
            "type": "number"
        },
        {
            "name": "txBytes",
            "baseName": "txBytes",
            "type": "number"
        },
        {
            "name": "txDropped",
            "baseName": "txDropped",
            "type": "number"
        },
        {
            "name": "txErrors",
            "baseName": "txErrors",
            "type": "number"
        },
        {
            "name": "rxDropped",
            "baseName": "rxDropped",
            "type": "number"
        },
        {
            "name": "rxErrors",
            "baseName": "rxErrors",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return DeviceOverview.attributeTypeMap;
    }
}

export namespace DeviceOverview {
    export enum StatusEnum {
        Disabled = <any> 'disabled',
        Active = <any> 'active',
        Unauthorized = <any> 'unauthorized',
        Disconnected = <any> 'disconnected',
        Unknown = <any> 'unknown'
    }
}
/**
* Device statistics + statistics for all interfaces
*/
export class DeviceStatistics {
    /**
    * Number of milliseconds between data points
    */
    'period'?: number;
    /**
    * Start and end of the interval
    */
    'interval'?: any;
    'ram'?: GraphDataSet;
    'cpu'?: GraphDataSet;
    'ping'?: GraphDataSet;
    'errors'?: GraphDataSet;
    'interfaces'?: Array<any>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "period",
            "baseName": "period",
            "type": "number"
        },
        {
            "name": "interval",
            "baseName": "interval",
            "type": "any"
        },
        {
            "name": "ram",
            "baseName": "ram",
            "type": "GraphDataSet"
        },
        {
            "name": "cpu",
            "baseName": "cpu",
            "type": "GraphDataSet"
        },
        {
            "name": "ping",
            "baseName": "ping",
            "type": "GraphDataSet"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "GraphDataSet"
        },
        {
            "name": "interfaces",
            "baseName": "interfaces",
            "type": "Array<any>"
        }    ];

    static getAttributeTypeMap() {
        return DeviceStatistics.attributeTypeMap;
    }
}

/**
* Read-only overview for device list
*/
export class DeviceStatusOverview {
    'identification'?: DeviceIdentification;
    'overview'?: DeviceOverview;
    'firmware'?: DeviceFirmware;
    /**
    * nullable field with variable properties depending on device type
    */
    'attributes'?: any;
    /**
    * nullable string
    */
    'parentId'?: string;
    'latestBackup'?: LatestBackup;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "identification",
            "baseName": "identification",
            "type": "DeviceIdentification"
        },
        {
            "name": "overview",
            "baseName": "overview",
            "type": "DeviceOverview"
        },
        {
            "name": "firmware",
            "baseName": "firmware",
            "type": "DeviceFirmware"
        },
        {
            "name": "attributes",
            "baseName": "attributes",
            "type": "any"
        },
        {
            "name": "parentId",
            "baseName": "parentId",
            "type": "string"
        },
        {
            "name": "latestBackup",
            "baseName": "latestBackup",
            "type": "LatestBackup"
        }    ];

    static getAttributeTypeMap() {
        return DeviceStatusOverview.attributeTypeMap;
    }
}

export class DeviceUpgradeStatus {
    'status'?: string;
    'error'?: string;
    /**
    * unix timestamp in ms
    */
    'changedAt'?: number;
    /**
    * duration in ms
    */
    'expectedDuration'?: number;
    'firmware'?: Firmware;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        },
        {
            "name": "changedAt",
            "baseName": "changedAt",
            "type": "number"
        },
        {
            "name": "expectedDuration",
            "baseName": "expectedDuration",
            "type": "number"
        },
        {
            "name": "firmware",
            "baseName": "firmware",
            "type": "Firmware"
        }    ];

    static getAttributeTypeMap() {
        return DeviceUpgradeStatus.attributeTypeMap;
    }
}

export class DiscoveryDevice {
    'identification'?: DiscoveryDeviceIdentification;
    /**
    * IP address of the device
    */
    'ip'?: string;
    /**
    * Firmware version overview
    */
    'firmware'?: any;
    'connect'?: any;
    /**
    * If status is Unconnected these flags indicate the problem
    */
    'flags'?: any;
    'authentication'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "identification",
            "baseName": "identification",
            "type": "DiscoveryDeviceIdentification"
        },
        {
            "name": "ip",
            "baseName": "ip",
            "type": "string"
        },
        {
            "name": "firmware",
            "baseName": "firmware",
            "type": "any"
        },
        {
            "name": "connect",
            "baseName": "connect",
            "type": "any"
        },
        {
            "name": "flags",
            "baseName": "flags",
            "type": "any"
        },
        {
            "name": "authentication",
            "baseName": "authentication",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return DiscoveryDevice.attributeTypeMap;
    }
}

export class DiscoveryDeviceIdentification {
    /**
    * UUID
    */
    'id'?: string;
    'firmwareVersion'?: string;
    /**
    * value from models enum
    */
    'model'?: string;
    /**
    * autogenerated
    */
    'name'?: string;
    /**
    * device mac address
    */
    'mac'?: string;
    /**
    * value from type enum
    */
    'type'?: string;
    /**
    * value from category enum
    */
    'category'?: string;
    'siteId'?: string;
    /**
    * device is added to nms
    */
    'authorized'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "firmwareVersion",
            "baseName": "firmwareVersion",
            "type": "string"
        },
        {
            "name": "model",
            "baseName": "model",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "mac",
            "baseName": "mac",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "category",
            "baseName": "category",
            "type": "string"
        },
        {
            "name": "siteId",
            "baseName": "siteId",
            "type": "string"
        },
        {
            "name": "authorized",
            "baseName": "authorized",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return DiscoveryDeviceIdentification.attributeTypeMap;
    }
}

export class DiscoveryResult {
    'identification'?: DiscoveryResultIdentification;
    'devices'?: Array<DiscoveryDevice>;
    /**
    * User UUID
    */
    'userId'?: string;
    /**
    * State of scanning
    */
    'status'?: DiscoveryResult.StatusEnum;
    /**
    * Error message
    */
    'error'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "identification",
            "baseName": "identification",
            "type": "DiscoveryResultIdentification"
        },
        {
            "name": "devices",
            "baseName": "devices",
            "type": "Array<DiscoveryDevice>"
        },
        {
            "name": "userId",
            "baseName": "userId",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "DiscoveryResult.StatusEnum"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DiscoveryResult.attributeTypeMap;
    }
}

export namespace DiscoveryResult {
    export enum StatusEnum {
        InProgress = <any> 'InProgress',
        Success = <any> 'Success',
        Failed = <any> 'Failed',
        Canceled = <any> 'Canceled'
    }
}
export class DiscoveryResultIdentification {
    /**
    * UUID of the result
    */
    'id'?: string;
    /**
    * Scan method - ip range or import
    */
    'method'?: string;
    /**
    * Ip range input - nullable string
    */
    'ipRange'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "method",
            "baseName": "method",
            "type": "string"
        },
        {
            "name": "ipRange",
            "baseName": "ipRange",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DiscoveryResultIdentification.attributeTypeMap;
    }
}

/**
* enumerations (codebooks)
*/
export class Enums {
    'interfaceIdentificationTypeEnum'?: any;
    'ponAuthorizationTypeEnum'?: any;
    'ipAddressTypeEnum'?: any;
    'mailServerTypeEnum'?: any;
    'serviceEnum'?: any;
    'serviceLabelEnum'?: any;
    'statusEnum'?: any;
    'statusLabelEnum'?: any;
    'siteTypeEnum'?: any;
    'alertTypeEnum'?: any;
    'wifiAuthenticationEnum'?: WifiAuthenticationEnum;
    'wifiSecurityEnum'?: WifiSecurityEnum;
    'wirelessModeEnum'?: WirelessModeEnum;
    'networkModeEnum'?: NetworkModeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "interfaceIdentificationTypeEnum",
            "baseName": "InterfaceIdentificationTypeEnum",
            "type": "any"
        },
        {
            "name": "ponAuthorizationTypeEnum",
            "baseName": "PonAuthorizationTypeEnum",
            "type": "any"
        },
        {
            "name": "ipAddressTypeEnum",
            "baseName": "IpAddressTypeEnum",
            "type": "any"
        },
        {
            "name": "mailServerTypeEnum",
            "baseName": "MailServerTypeEnum",
            "type": "any"
        },
        {
            "name": "serviceEnum",
            "baseName": "ServiceEnum",
            "type": "any"
        },
        {
            "name": "serviceLabelEnum",
            "baseName": "ServiceLabelEnum",
            "type": "any"
        },
        {
            "name": "statusEnum",
            "baseName": "StatusEnum",
            "type": "any"
        },
        {
            "name": "statusLabelEnum",
            "baseName": "StatusLabelEnum",
            "type": "any"
        },
        {
            "name": "siteTypeEnum",
            "baseName": "SiteTypeEnum",
            "type": "any"
        },
        {
            "name": "alertTypeEnum",
            "baseName": "AlertTypeEnum",
            "type": "any"
        },
        {
            "name": "wifiAuthenticationEnum",
            "baseName": "WifiAuthenticationEnum",
            "type": "WifiAuthenticationEnum"
        },
        {
            "name": "wifiSecurityEnum",
            "baseName": "WifiSecurityEnum",
            "type": "WifiSecurityEnum"
        },
        {
            "name": "wirelessModeEnum",
            "baseName": "WirelessModeEnum",
            "type": "WirelessModeEnum"
        },
        {
            "name": "networkModeEnum",
            "baseName": "NetworkModeEnum",
            "type": "NetworkModeEnum"
        }    ];

    static getAttributeTypeMap() {
        return Enums.attributeTypeMap;
    }
}

/**
* Read-only erouter detail
*/
export class ErouterStatusDetail {
    'identification'?: DeviceIdentification;
    'overview'?: DeviceOverview;
    'firmware'?: DeviceFirmware;
    'upgrade'?: DeviceUpgradeStatus;
    'gateway'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "identification",
            "baseName": "identification",
            "type": "DeviceIdentification"
        },
        {
            "name": "overview",
            "baseName": "overview",
            "type": "DeviceOverview"
        },
        {
            "name": "firmware",
            "baseName": "firmware",
            "type": "DeviceFirmware"
        },
        {
            "name": "upgrade",
            "baseName": "upgrade",
            "type": "DeviceUpgradeStatus"
        },
        {
            "name": "gateway",
            "baseName": "gateway",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ErouterStatusDetail.attributeTypeMap;
    }
}

export class Firmware {
    'identification'?: FirmwareIdentification;
    'semver'?: FirmwareSemver;
    /**
    * Download url of the firmware image
    */
    'url'?: string;
    /**
    * Size in bytes
    */
    'size'?: number;
    /**
    * Unix timestamp in miliseconds
    */
    'date'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "identification",
            "baseName": "identification",
            "type": "FirmwareIdentification"
        },
        {
            "name": "semver",
            "baseName": "semver",
            "type": "FirmwareSemver"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "date",
            "baseName": "date",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Firmware.attributeTypeMap;
    }
}

export class FirmwareIdentification {
    /**
    * Synthetic ID, combination of filename and origin
    */
    'id'?: string;
    'version'?: string;
    /**
    * Name of the firmware image file
    */
    'filename'?: string;
    /**
    * Firmware origin
    */
    'origin'?: FirmwareIdentification.OriginEnum;
    /**
    * Firmware platformId, e.g. e50, e100 ...
    */
    'platformId'?: string;
    /**
    * Supported models
    */
    'models'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "string"
        },
        {
            "name": "filename",
            "baseName": "filename",
            "type": "string"
        },
        {
            "name": "origin",
            "baseName": "origin",
            "type": "FirmwareIdentification.OriginEnum"
        },
        {
            "name": "platformId",
            "baseName": "platformId",
            "type": "string"
        },
        {
            "name": "models",
            "baseName": "models",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return FirmwareIdentification.attributeTypeMap;
    }
}

export namespace FirmwareIdentification {
    export enum OriginEnum {
        Ubnt = <any> 'ubnt',
        Manual = <any> 'manual',
        Unms = <any> 'unms'
    }
}
export class FirmwareSemver {
    'major'?: number;
    'minor'?: number;
    'patch'?: number;
    'prerelease'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "major",
            "baseName": "major",
            "type": "number"
        },
        {
            "name": "minor",
            "baseName": "minor",
            "type": "number"
        },
        {
            "name": "patch",
            "baseName": "patch",
            "type": "number"
        },
        {
            "name": "prerelease",
            "baseName": "prerelease",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return FirmwareSemver.attributeTypeMap;
    }
}

/**
* Generic graph data set
*/
export class GraphDataSet extends Array<any> {

    static discriminator: string | undefined = undefined;

}

export class ImageIdentification {
    'id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ImageIdentification.attributeTypeMap;
    }
}

export class ImageOverview {
    'identification'?: ImageIdentification;
    'name'?: string;
    'description'?: string;
    'fileName'?: string;
    'fileType'?: string;
    'height'?: number;
    'width'?: number;
    /**
    * in KB
    */
    'size'?: number;
    'date'?: string;
    'thumbUrl'?: string;
    'fullUrl'?: string;
    /**
    * image order in sites gallery
    */
    'order'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "identification",
            "baseName": "identification",
            "type": "ImageIdentification"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "fileName",
            "baseName": "fileName",
            "type": "string"
        },
        {
            "name": "fileType",
            "baseName": "fileType",
            "type": "string"
        },
        {
            "name": "height",
            "baseName": "height",
            "type": "number"
        },
        {
            "name": "width",
            "baseName": "width",
            "type": "number"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "date",
            "baseName": "date",
            "type": "string"
        },
        {
            "name": "thumbUrl",
            "baseName": "thumbUrl",
            "type": "string"
        },
        {
            "name": "fullUrl",
            "baseName": "fullUrl",
            "type": "string"
        },
        {
            "name": "order",
            "baseName": "order",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ImageOverview.attributeTypeMap;
    }
}

export class InterfaceAddressOverview {
    'type'?: InterfaceAddressType;
    /**
    * nullable string
    */
    'cidr'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "InterfaceAddressType"
        },
        {
            "name": "cidr",
            "baseName": "cidr",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InterfaceAddressOverview.attributeTypeMap;
    }
}

/**
* nullable string
*/
export class InterfaceAddressType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return InterfaceAddressType.attributeTypeMap;
    }
}

/**
* Read-write interface configuration
*/
export class InterfaceConfig {
    'identification'?: InterfaceIdentification;
    /**
    * Enable/Disable
    */
    'enabled'?: boolean;
    'status'?: any;
    'addresses'?: Array<InterfaceAddressOverview>;
    'speed'?: InterfaceConfig.SpeedEnum;
    'mtu'?: MTU;
    'proxyARP'?: boolean;
    'poe'?: POE;
    '_switch'?: any;
    'vlan'?: any;
    'pppoe'?: any;
    'pon'?: any;
    /**
    * nullable field
    */
    'bridge'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "identification",
            "baseName": "identification",
            "type": "InterfaceIdentification"
        },
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "any"
        },
        {
            "name": "addresses",
            "baseName": "addresses",
            "type": "Array<InterfaceAddressOverview>"
        },
        {
            "name": "speed",
            "baseName": "speed",
            "type": "InterfaceConfig.SpeedEnum"
        },
        {
            "name": "mtu",
            "baseName": "mtu",
            "type": "MTU"
        },
        {
            "name": "proxyARP",
            "baseName": "proxyARP",
            "type": "boolean"
        },
        {
            "name": "poe",
            "baseName": "poe",
            "type": "POE"
        },
        {
            "name": "_switch",
            "baseName": "switch",
            "type": "any"
        },
        {
            "name": "vlan",
            "baseName": "vlan",
            "type": "any"
        },
        {
            "name": "pppoe",
            "baseName": "pppoe",
            "type": "any"
        },
        {
            "name": "pon",
            "baseName": "pon",
            "type": "any"
        },
        {
            "name": "bridge",
            "baseName": "bridge",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return InterfaceConfig.attributeTypeMap;
    }
}

export namespace InterfaceConfig {
    export enum SpeedEnum {
        Auto = <any> 'auto',
        _100full = <any> '100full',
        _100half = <any> '100half',
        _10full = <any> '10full',
        _10half = <any> '10half',
        _1000 = <any> '1000',
        _10G = <any> '10G'
    }
}
/**
* read-only interface identification
*/
export class InterfaceIdentification {
    /**
    * physical port position
    */
    'position'?: number;
    'type'?: InterfaceIdentification.TypeEnum;
    /**
    * interface name
    */
    'name'?: string;
    /**
    * computed display name from name and description
    */
    'displayName'?: string;
    /**
    * nullable string
    */
    'description'?: string;
    'mac'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "position",
            "baseName": "position",
            "type": "number"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "InterfaceIdentification.TypeEnum"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "displayName",
            "baseName": "displayName",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "mac",
            "baseName": "mac",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InterfaceIdentification.attributeTypeMap;
    }
}

export namespace InterfaceIdentification {
    export enum TypeEnum {
        Ethernet = <any> 'ethernet',
        Pon = <any> 'pon',
        Switch = <any> 'switch',
        Bridge = <any> 'bridge'
    }
}
/**
* Read-only interface overview
*/
export class InterfaceOverview {
    'identification'?: InterfaceIdentification;
    'addresses'?: Array<InterfaceAddressOverview>;
    'status'?: any;
    'statistics'?: InterfaceStatistics;
    'pppoe'?: any;
    'vlan'?: any;
    'poe'?: POE;
    /**
    * Enable/Disable
    */
    'enabled'?: boolean;
    /**
    * Logical switch which determines if it makes sense to display the interface to user
    */
    'visible'?: boolean;
    /**
    * Logical switch which determines if it makes sense to display interface statistics to user
    */
    'canDisplayStatistics'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "identification",
            "baseName": "identification",
            "type": "InterfaceIdentification"
        },
        {
            "name": "addresses",
            "baseName": "addresses",
            "type": "Array<InterfaceAddressOverview>"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "any"
        },
        {
            "name": "statistics",
            "baseName": "statistics",
            "type": "InterfaceStatistics"
        },
        {
            "name": "pppoe",
            "baseName": "pppoe",
            "type": "any"
        },
        {
            "name": "vlan",
            "baseName": "vlan",
            "type": "any"
        },
        {
            "name": "poe",
            "baseName": "poe",
            "type": "POE"
        },
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        },
        {
            "name": "visible",
            "baseName": "visible",
            "type": "boolean"
        },
        {
            "name": "canDisplayStatistics",
            "baseName": "canDisplayStatistics",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return InterfaceOverview.attributeTypeMap;
    }
}

export class InterfaceStatistics {
    'timestamp'?: string;
    'rxrate'?: number;
    'rxbytes'?: number;
    'txrate'?: number;
    'txbytes'?: number;
    'dropped'?: number;
    'errors'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "timestamp",
            "baseName": "timestamp",
            "type": "string"
        },
        {
            "name": "rxrate",
            "baseName": "rxrate",
            "type": "number"
        },
        {
            "name": "rxbytes",
            "baseName": "rxbytes",
            "type": "number"
        },
        {
            "name": "txrate",
            "baseName": "txrate",
            "type": "number"
        },
        {
            "name": "txbytes",
            "baseName": "txbytes",
            "type": "number"
        },
        {
            "name": "dropped",
            "baseName": "dropped",
            "type": "number"
        },
        {
            "name": "errors",
            "baseName": "errors",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return InterfaceStatistics.attributeTypeMap;
    }
}

/**
* Interface detail status
*/
export class InterfaceStatus {
    /**
    * State of Interface
    */
    'status'?: InterfaceStatus.StatusEnum;
    /**
    * 100 Mbps - Full Duplex
    */
    'description'?: string;
    /**
    * connected/disconnected
    */
    'plugged'?: boolean;
    /**
    * float
    */
    'speed'?: number;
    'duplex'?: boolean;
    'autoneg'?: boolean;
    /**
    * nullable object
    */
    'sfp'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "InterfaceStatus.StatusEnum"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "plugged",
            "baseName": "plugged",
            "type": "boolean"
        },
        {
            "name": "speed",
            "baseName": "speed",
            "type": "number"
        },
        {
            "name": "duplex",
            "baseName": "duplex",
            "type": "boolean"
        },
        {
            "name": "autoneg",
            "baseName": "autoneg",
            "type": "boolean"
        },
        {
            "name": "sfp",
            "baseName": "sfp",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return InterfaceStatus.attributeTypeMap;
    }
}

export namespace InterfaceStatus {
    export enum StatusEnum {
        Active = <any> 'Active',
        Disconnected = <any> 'Disconnected',
        Disabled = <any> 'Disabled'
    }
}
/**
* Latest backup info
*/
export class LatestBackup {
    /**
    * latest backup id
    */
    'hash'?: string;
    /**
    * latest backup timestamp
    */
    'timestamp'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "hash",
            "baseName": "hash",
            "type": "string"
        },
        {
            "name": "timestamp",
            "baseName": "timestamp",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LatestBackup.attributeTypeMap;
    }
}

export class LogItem {
    'id'?: string;
    /**
    * unix timestamp in milliseconds
    */
    'timestamp'?: number;
    'message'?: string;
    'level'?: LogItem.LevelEnum;
    'tags'?: Array<LogItem.TagsEnum>;
    'device'?: any;
    'site'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "timestamp",
            "baseName": "timestamp",
            "type": "number"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "level",
            "baseName": "level",
            "type": "LogItem.LevelEnum"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<LogItem.TagsEnum>"
        },
        {
            "name": "device",
            "baseName": "device",
            "type": "any"
        },
        {
            "name": "site",
            "baseName": "site",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return LogItem.attributeTypeMap;
    }
}

export namespace LogItem {
    export enum LevelEnum {
        Info = <any> 'info',
        Warning = <any> 'warning',
        Error = <any> 'error'
    }
    export enum TagsEnum {
        Site = <any> 'site',
        Device = <any> 'device',
        Endpoint = <any> 'endpoint',
        Network = <any> 'network'
    }
}
export class Login {
    'password'?: string;
    'username'?: string;
    /**
    * Token specific lifetime in miliseconds max to one week. Almost all api calls (user explicit actions, without technicall refresh calls) refresh token validity.
    */
    'sessionTimeout'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        },
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        },
        {
            "name": "sessionTimeout",
            "baseName": "sessionTimeout",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Login.attributeTypeMap;
    }
}

/**
* Maximum transmission unit <68, 2018>
*/
export class MTU {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return MTU.attributeTypeMap;
    }
}

export class MailServer {
    'type'?: MailServer.TypeEnum;
    'gmailUsername'?: string;
    'gmailPassword'?: string;
    'customSmtpHostname'?: string;
    'customSmtpPort'?: number;
    'customSmtpSslEnabled'?: boolean;
    'customSmtpAuthEnabled'?: boolean;
    'customSmtpUsername'?: string;
    'customSmtpPassword'?: string;
    'customSmtpSender'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "MailServer.TypeEnum"
        },
        {
            "name": "gmailUsername",
            "baseName": "gmailUsername",
            "type": "string"
        },
        {
            "name": "gmailPassword",
            "baseName": "gmailPassword",
            "type": "string"
        },
        {
            "name": "customSmtpHostname",
            "baseName": "customSmtpHostname",
            "type": "string"
        },
        {
            "name": "customSmtpPort",
            "baseName": "customSmtpPort",
            "type": "number"
        },
        {
            "name": "customSmtpSslEnabled",
            "baseName": "customSmtpSslEnabled",
            "type": "boolean"
        },
        {
            "name": "customSmtpAuthEnabled",
            "baseName": "customSmtpAuthEnabled",
            "type": "boolean"
        },
        {
            "name": "customSmtpUsername",
            "baseName": "customSmtpUsername",
            "type": "string"
        },
        {
            "name": "customSmtpPassword",
            "baseName": "customSmtpPassword",
            "type": "string"
        },
        {
            "name": "customSmtpSender",
            "baseName": "customSmtpSender",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MailServer.attributeTypeMap;
    }
}

export namespace MailServer {
    export enum TypeEnum {
        Nosmtp = <any> 'nosmtp',
        Cloud = <any> 'cloud',
        Gmail = <any> 'gmail',
        Smtp = <any> 'smtp'
    }
}
export class ModelError {
    'error'?: number;
    'message'?: string;
    'statusCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "error",
            "baseName": "error",
            "type": "number"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "statusCode",
            "baseName": "statusCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ModelError.attributeTypeMap;
    }
}

/**
* UNMS statistics for UNMS dashboard
*/
export class NMSStatistics {
    /**
    * Number of milliseconds between data points
    */
    'period'?: number;
    /**
    * Start and end of the interval
    */
    'interval'?: any;
    /**
    * Network health in percentage. Ratio of online/disconnected sites and clients.
    */
    'networkHealth'?: GraphDataSet;
    'allSites'?: GraphDataSet;
    'liveSites'?: GraphDataSet;
    'allClients'?: GraphDataSet;
    'liveClients'?: GraphDataSet;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "period",
            "baseName": "period",
            "type": "number"
        },
        {
            "name": "interval",
            "baseName": "interval",
            "type": "any"
        },
        {
            "name": "networkHealth",
            "baseName": "networkHealth",
            "type": "GraphDataSet"
        },
        {
            "name": "allSites",
            "baseName": "allSites",
            "type": "GraphDataSet"
        },
        {
            "name": "liveSites",
            "baseName": "liveSites",
            "type": "GraphDataSet"
        },
        {
            "name": "allClients",
            "baseName": "allClients",
            "type": "GraphDataSet"
        },
        {
            "name": "liveClients",
            "baseName": "liveClients",
            "type": "GraphDataSet"
        }    ];

    static getAttributeTypeMap() {
        return NMSStatistics.attributeTypeMap;
    }
}

export class NetworkModeEnum {
    'bridge'?: NetworkModeEnum.BridgeEnum;
    'router'?: NetworkModeEnum.RouterEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "bridge",
            "baseName": "Bridge",
            "type": "NetworkModeEnum.BridgeEnum"
        },
        {
            "name": "router",
            "baseName": "Router",
            "type": "NetworkModeEnum.RouterEnum"
        }    ];

    static getAttributeTypeMap() {
        return NetworkModeEnum.attributeTypeMap;
    }
}

export namespace NetworkModeEnum {
    export enum BridgeEnum {
        Bridge = <any> 'bridge'
    }
    export enum RouterEnum {
        Router = <any> 'router'
    }
}
export class NmsSettings {
    'hostname'?: string;
    'useLetsEncrypt'?: boolean;
    'letsEncryptError'?: string;
    'letsEncryptTimestamp'?: number;
    'autoBackups'?: boolean;
    'maps'?: any;
    'devicePingAddress'?: string;
    'devicePingIntervalNormal'?: number;
    'devicePingIntervalOutage'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "hostname",
            "baseName": "hostname",
            "type": "string"
        },
        {
            "name": "useLetsEncrypt",
            "baseName": "useLetsEncrypt",
            "type": "boolean"
        },
        {
            "name": "letsEncryptError",
            "baseName": "letsEncryptError",
            "type": "string"
        },
        {
            "name": "letsEncryptTimestamp",
            "baseName": "letsEncryptTimestamp",
            "type": "number"
        },
        {
            "name": "autoBackups",
            "baseName": "autoBackups",
            "type": "boolean"
        },
        {
            "name": "maps",
            "baseName": "maps",
            "type": "any"
        },
        {
            "name": "devicePingAddress",
            "baseName": "devicePingAddress",
            "type": "string"
        },
        {
            "name": "devicePingIntervalNormal",
            "baseName": "devicePingIntervalNormal",
            "type": "number"
        },
        {
            "name": "devicePingIntervalOutage",
            "baseName": "devicePingIntervalOutage",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return NmsSettings.attributeTypeMap;
    }
}

export class NmsSummary {
    /**
    * Number of unauthorized devices
    */
    'devicesUnauthorizedCount'?: number;
    /**
    * Number of unread logs since latest logs view
    */
    'logsUnreadCount'?: number;
    /**
    * Number of unread outages since latest logs view
    */
    'outagesUnreadCount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "devicesUnauthorizedCount",
            "baseName": "devicesUnauthorizedCount",
            "type": "number"
        },
        {
            "name": "logsUnreadCount",
            "baseName": "logsUnreadCount",
            "type": "number"
        },
        {
            "name": "outagesUnreadCount",
            "baseName": "outagesUnreadCount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return NmsSummary.attributeTypeMap;
    }
}

export class NmsUpdateStatus {
    'canNmsUpdate'?: boolean;
    'nmsUpdateStatus'?: NmsUpdateStatus.NmsUpdateStatusEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "canNmsUpdate",
            "baseName": "canNmsUpdate",
            "type": "boolean"
        },
        {
            "name": "nmsUpdateStatus",
            "baseName": "nmsUpdateStatus",
            "type": "NmsUpdateStatus.NmsUpdateStatusEnum"
        }    ];

    static getAttributeTypeMap() {
        return NmsUpdateStatus.attributeTypeMap;
    }
}

export namespace NmsUpdateStatus {
    export enum NmsUpdateStatusEnum {
        Ready = <any> 'ready',
        Requested = <any> 'requested',
        Started = <any> 'started',
        Updating = <any> 'updating'
    }
}
/**
* OLT ONU profile
*/
export class OLTONUProfile {
    'adminPassword'?: string;
    'id'?: string;
    'name'?: string;
    'mode'?: OLTONUProfile.ModeEnum;
    /**
    * cidr
    */
    'lanAddress'?: string;
    'lanProvisioned'?: boolean;
    'linkSpeed'?: OLTONUProfile.LinkSpeedEnum;
    'onuCount'?: number;
    'bridge'?: any;
    'router'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "adminPassword",
            "baseName": "adminPassword",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "mode",
            "baseName": "mode",
            "type": "OLTONUProfile.ModeEnum"
        },
        {
            "name": "lanAddress",
            "baseName": "lanAddress",
            "type": "string"
        },
        {
            "name": "lanProvisioned",
            "baseName": "lanProvisioned",
            "type": "boolean"
        },
        {
            "name": "linkSpeed",
            "baseName": "linkSpeed",
            "type": "OLTONUProfile.LinkSpeedEnum"
        },
        {
            "name": "onuCount",
            "baseName": "onuCount",
            "type": "number"
        },
        {
            "name": "bridge",
            "baseName": "bridge",
            "type": "any"
        },
        {
            "name": "router",
            "baseName": "router",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return OLTONUProfile.attributeTypeMap;
    }
}

export namespace OLTONUProfile {
    export enum ModeEnum {
        Router = <any> 'router',
        Bridge = <any> 'bridge'
    }
    export enum LinkSpeedEnum {
        Auto = <any> 'auto',
        _1000full = <any> '1000full',
        _100full = <any> '100full',
        _100half = <any> '100half',
        _10full = <any> '10full',
        _10half = <any> '10half'
    }
}
/**
* Read-only OLT detail
*/
export class OLTStatusDetail {
    'identification'?: DeviceIdentification;
    'overview'?: DeviceOverview;
    'firmware'?: DeviceFirmware;
    'upgrade'?: DeviceUpgradeStatus;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "identification",
            "baseName": "identification",
            "type": "DeviceIdentification"
        },
        {
            "name": "overview",
            "baseName": "overview",
            "type": "DeviceOverview"
        },
        {
            "name": "firmware",
            "baseName": "firmware",
            "type": "DeviceFirmware"
        },
        {
            "name": "upgrade",
            "baseName": "upgrade",
            "type": "DeviceUpgradeStatus"
        }    ];

    static getAttributeTypeMap() {
        return OLTStatusDetail.attributeTypeMap;
    }
}

/**
* Read-only ONU client
*/
export class ONUClient {
    'mac'?: string;
    'vendor'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "mac",
            "baseName": "mac",
            "type": "string"
        },
        {
            "name": "vendor",
            "baseName": "vendor",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ONUClient.attributeTypeMap;
    }
}

/**
* Read-only ONU detail
*/
export class ONUStatusOverview {
    'identification'?: DeviceIdentification;
    'overview'?: DeviceOverview;
    'firmware'?: DeviceFirmware;
    /**
    * nullable string
    */
    'parentId'?: string;
    /**
    * Logical switch which determines if it makes sense to display device statistics to user
    */
    'canDisplayStatistics'?: boolean;
    'olt'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "identification",
            "baseName": "identification",
            "type": "DeviceIdentification"
        },
        {
            "name": "overview",
            "baseName": "overview",
            "type": "DeviceOverview"
        },
        {
            "name": "firmware",
            "baseName": "firmware",
            "type": "DeviceFirmware"
        },
        {
            "name": "parentId",
            "baseName": "parentId",
            "type": "string"
        },
        {
            "name": "canDisplayStatistics",
            "baseName": "canDisplayStatistics",
            "type": "boolean"
        },
        {
            "name": "olt",
            "baseName": "olt",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return ONUStatusOverview.attributeTypeMap;
    }
}

export class OSPFArea {
    /**
    * OSPF area in decimal or dotted decimal notation (0.0.0.0)
    */
    'id'?: string;
    'type'?: OSPFArea.TypeEnum;
    'auth'?: OSPFAuthorization;
    'networks'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "OSPFArea.TypeEnum"
        },
        {
            "name": "auth",
            "baseName": "auth",
            "type": "OSPFAuthorization"
        },
        {
            "name": "networks",
            "baseName": "networks",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return OSPFArea.attributeTypeMap;
    }
}

export namespace OSPFArea {
    export enum TypeEnum {
        Normal = <any> 'normal',
        Nssa = <any> 'nssa',
        Stub = <any> 'stub'
    }
}
/**
* off - Off, md5 - MD5/sec, plaintext-password - Plain text
*/
export class OSPFAuthorization {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return OSPFAuthorization.attributeTypeMap;
    }
}

export class OSPFConfig {
    /**
    * Override the default router ID (IPv4 address)
    */
    'router'?: string;
    'redistributeConnected'?: any;
    'redistributeStatic'?: any;
    'redistributeDefaultRoute'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "router",
            "baseName": "router",
            "type": "string"
        },
        {
            "name": "redistributeConnected",
            "baseName": "redistributeConnected",
            "type": "any"
        },
        {
            "name": "redistributeStatic",
            "baseName": "redistributeStatic",
            "type": "any"
        },
        {
            "name": "redistributeDefaultRoute",
            "baseName": "redistributeDefaultRoute",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return OSPFConfig.attributeTypeMap;
    }
}

export class OSPFInterface {
    'auth'?: OSPFAuthorization;
    'authKey'?: string;
    /**
    * 1 - 65535
    */
    'cost'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "auth",
            "baseName": "auth",
            "type": "OSPFAuthorization"
        },
        {
            "name": "authKey",
            "baseName": "authKey",
            "type": "string"
        },
        {
            "name": "cost",
            "baseName": "cost",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return OSPFInterface.attributeTypeMap;
    }
}

export class OutageItem {
    'startTimestamp'?: string;
    'endTimestamp'?: string;
    'deviceIdentification'?: DeviceIdentification;
    'type'?: OutageItem.TypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "startTimestamp",
            "baseName": "startTimestamp",
            "type": "string"
        },
        {
            "name": "endTimestamp",
            "baseName": "endTimestamp",
            "type": "string"
        },
        {
            "name": "deviceIdentification",
            "baseName": "deviceIdentification",
            "type": "DeviceIdentification"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "OutageItem.TypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return OutageItem.attributeTypeMap;
    }
}

export namespace OutageItem {
    export enum TypeEnum {
        Quality = <any> 'quality',
        Outage = <any> 'outage'
    }
}
export class POE {
    /**
    * Power over Ethernet
    */
    'output'?: POE.OutputEnum;
    'capacities'?: Array<POE.CapacitiesEnum>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "output",
            "baseName": "output",
            "type": "POE.OutputEnum"
        },
        {
            "name": "capacities",
            "baseName": "capacities",
            "type": "Array<POE.CapacitiesEnum>"
        }    ];

    static getAttributeTypeMap() {
        return POE.attributeTypeMap;
    }
}

export namespace POE {
    export enum OutputEnum {
        Off = <any> 'off',
        _24v = <any> '24v',
        _48v = <any> '48v',
        _24v4pair = <any> '24v-4pair',
        _54v4pair = <any> '54v-4pair',
        Pthru = <any> 'pthru'
    }
    export enum CapacitiesEnum {
        Off = <any> 'off',
        _24v = <any> '24v',
        _48v = <any> '48v',
        _24v4pair = <any> '24v-4pair',
        _54v4pair = <any> '54v-4pair',
        Pthru = <any> 'pthru'
    }
}
/**
* value 0 - 4094
*/
export class PPPOEID {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return PPPOEID.attributeTypeMap;
    }
}

export class PonAuthentication {
    /**
    * No auth, Pre-shared secret
    */
    'authorizationType'?: PonAuthentication.AuthorizationTypeEnum;
    'preSharedSecret'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "authorizationType",
            "baseName": "authorizationType",
            "type": "PonAuthentication.AuthorizationTypeEnum"
        },
        {
            "name": "preSharedSecret",
            "baseName": "preSharedSecret",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PonAuthentication.attributeTypeMap;
    }
}

export namespace PonAuthentication {
    export enum AuthorizationTypeEnum {
        NoAuth = <any> 'no-auth',
        PreSharedSecret = <any> 'pre-shared-secret'
    }
}
export class RouteOverview {
    /**
    * K - kernel route, C - connected, S - static, R - RIP, O - OSPF, I - ISIS, B - BGP
    */
    'type'?: RouteOverview.TypeEnum;
    /**
    * nullable; bool only for static routes
    */
    'enabled'?: boolean;
    /**
    * cidr
    */
    'destination'?: string;
    /**
    * ip address
    */
    'gateway'?: string;
    'gatewayStatus'?: RouteOverview.GatewayStatusEnum;
    /**
    * interface name, for example eth0, eth1 etc.
    */
    '_interface'?: string;
    'distance'?: number;
    /**
    * true if route type includes *, for example S>*
    */
    'fib'?: boolean;
    /**
    * true if route type includes >, for example S>*
    */
    'selected'?: boolean;
    'description'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "RouteOverview.TypeEnum"
        },
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        },
        {
            "name": "destination",
            "baseName": "destination",
            "type": "string"
        },
        {
            "name": "gateway",
            "baseName": "gateway",
            "type": "string"
        },
        {
            "name": "gatewayStatus",
            "baseName": "gatewayStatus",
            "type": "RouteOverview.GatewayStatusEnum"
        },
        {
            "name": "_interface",
            "baseName": "interface",
            "type": "string"
        },
        {
            "name": "distance",
            "baseName": "distance",
            "type": "number"
        },
        {
            "name": "fib",
            "baseName": "fib",
            "type": "boolean"
        },
        {
            "name": "selected",
            "baseName": "selected",
            "type": "boolean"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RouteOverview.attributeTypeMap;
    }
}

export namespace RouteOverview {
    export enum TypeEnum {
        KernelRoute = <any> 'KernelRoute',
        Connected = <any> 'Connected',
        Static = <any> 'Static',
        RIP = <any> 'RIP',
        OSPF = <any> 'OSPF',
        ISIS = <any> 'ISIS',
        BGP = <any> 'BGP'
    }
    export enum GatewayStatusEnum {
        Reachable = <any> 'reachable',
        Unreachable = <any> 'unreachable'
    }
}
export class Services {
    'ntpClient'?: any;
    'sshServer'?: any;
    'systemLog'?: any;
    'telnetServer'?: any;
    'snmpAgent'?: any;
    'webServer'?: any;
    'discovery'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ntpClient",
            "baseName": "ntpClient",
            "type": "any"
        },
        {
            "name": "sshServer",
            "baseName": "sshServer",
            "type": "any"
        },
        {
            "name": "systemLog",
            "baseName": "systemLog",
            "type": "any"
        },
        {
            "name": "telnetServer",
            "baseName": "telnetServer",
            "type": "any"
        },
        {
            "name": "snmpAgent",
            "baseName": "snmpAgent",
            "type": "any"
        },
        {
            "name": "webServer",
            "baseName": "webServer",
            "type": "any"
        },
        {
            "name": "discovery",
            "baseName": "discovery",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return Services.attributeTypeMap;
    }
}

export class SiteDescription {
    'note'?: string;
    'address'?: string;
    /**
    * nullable object
    */
    'location'?: any;
    /**
    * Elevation on the surface of the earth
    */
    'elevation'?: number;
    /**
    * Height of the structure
    */
    'height'?: number;
    'contact'?: any;
    /**
    * Endpoints are sites without endpoints
    */
    'endpoints'?: Array<SiteIdentification>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "note",
            "baseName": "note",
            "type": "string"
        },
        {
            "name": "address",
            "baseName": "address",
            "type": "string"
        },
        {
            "name": "location",
            "baseName": "location",
            "type": "any"
        },
        {
            "name": "elevation",
            "baseName": "elevation",
            "type": "number"
        },
        {
            "name": "height",
            "baseName": "height",
            "type": "number"
        },
        {
            "name": "contact",
            "baseName": "contact",
            "type": "any"
        },
        {
            "name": "endpoints",
            "baseName": "endpoints",
            "type": "Array<SiteIdentification>"
        }    ];

    static getAttributeTypeMap() {
        return SiteDescription.attributeTypeMap;
    }
}

export class SiteIdentification {
    'id'?: string;
    'status'?: SiteIdentification.StatusEnum;
    'name'?: string;
    'type'?: SiteIdentification.TypeEnum;
    'parent'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "SiteIdentification.StatusEnum"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "SiteIdentification.TypeEnum"
        },
        {
            "name": "parent",
            "baseName": "parent",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return SiteIdentification.attributeTypeMap;
    }
}

export namespace SiteIdentification {
    export enum StatusEnum {
        Active = <any> 'active',
        Disconnected = <any> 'disconnected'
    }
    export enum TypeEnum {
        Site = <any> 'site',
        Endpoint = <any> 'endpoint'
    }
}
/**
* Gallery is created with site. There is only one gallery per site. Site devices is possible to load with /devices resource.
*/
export class SiteOverview {
    'identification'?: SiteIdentification;
    'description'?: SiteDescription;
    'notifications'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "identification",
            "baseName": "identification",
            "type": "SiteIdentification"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "SiteDescription"
        },
        {
            "name": "notifications",
            "baseName": "notifications",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return SiteOverview.attributeTypeMap;
    }
}

export class SshCredentials {
    'username'?: string;
    'password'?: string;
    /**
    * nullable, default 22, in range 1 - 65535
    */
    'port'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        },
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        },
        {
            "name": "port",
            "baseName": "port",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return SshCredentials.attributeTypeMap;
    }
}

export class StaticRoute {
    'type'?: StaticRoute.TypeEnum;
    /**
    * cidr
    */
    'destination'?: string;
    /**
    * ip address / nullable string
    */
    'gateway'?: string;
    /**
    * interface name, for example eth0, eth1 etc. / nullable string
    */
    '_interface'?: string;
    /**
    * 1 - 255
    */
    'distance'?: number;
    /**
    * nullable string
    */
    'description'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "StaticRoute.TypeEnum"
        },
        {
            "name": "destination",
            "baseName": "destination",
            "type": "string"
        },
        {
            "name": "gateway",
            "baseName": "gateway",
            "type": "string"
        },
        {
            "name": "_interface",
            "baseName": "interface",
            "type": "string"
        },
        {
            "name": "distance",
            "baseName": "distance",
            "type": "number"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StaticRoute.attributeTypeMap;
    }
}

export namespace StaticRoute {
    export enum TypeEnum {
        Interface = <any> 'interface',
        Blackhole = <any> 'blackhole',
        Gateway = <any> 'gateway'
    }
}
export class Station {
    /**
    * unknown
    */
    'timestamp'?: number;
    /**
    * IP Address of the station
    */
    'ipAddress'?: string;
    /**
    * Hostname of the station
    */
    'name'?: string;
    /**
    * Producing company of the station
    */
    'vendor'?: string;
    /**
    * Radio frequency type
    */
    'radio'?: Station.RadioEnum;
    'mac'?: string;
    /**
    * unknown
    */
    'upTime'?: number;
    /**
    * Latency in milliseconds
    */
    'latency'?: number;
    /**
    * Distance in meters
    */
    'distance'?: number;
    /**
    * Nullable property; Receieved Bytes
    */
    'rxBytes'?: number;
    /**
    * Nullable property; Transmitted Bytes
    */
    'txBytes'?: number;
    /**
    * Nullable property; Current download speed in bps
    */
    'rxRate'?: number;
    /**
    * Nullable property; Current upload speed in bps
    */
    'txRate'?: number;
    /**
    * Nullable prop; current receiving signal level (only for airmax devices), for example 55 dBm
    */
    'rxSignal'?: number;
    /**
    * Nullable prop; current transmitting signal level (only for airmax devices), for example 55 dBm
    */
    'txSignal'?: number;
    /**
    * Nullable prop; Calculated real possible download speed in bps (only for airmax devices)
    */
    'downlinkCapacity'?: number;
    /**
    * Nullable prop; Calculated real possible upload speed in bps (only for airmax devices)
    */
    'uplinkCapacity'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "timestamp",
            "baseName": "timestamp",
            "type": "number"
        },
        {
            "name": "ipAddress",
            "baseName": "ipAddress",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "vendor",
            "baseName": "vendor",
            "type": "string"
        },
        {
            "name": "radio",
            "baseName": "radio",
            "type": "Station.RadioEnum"
        },
        {
            "name": "mac",
            "baseName": "mac",
            "type": "string"
        },
        {
            "name": "upTime",
            "baseName": "upTime",
            "type": "number"
        },
        {
            "name": "latency",
            "baseName": "latency",
            "type": "number"
        },
        {
            "name": "distance",
            "baseName": "distance",
            "type": "number"
        },
        {
            "name": "rxBytes",
            "baseName": "rxBytes",
            "type": "number"
        },
        {
            "name": "txBytes",
            "baseName": "txBytes",
            "type": "number"
        },
        {
            "name": "rxRate",
            "baseName": "rxRate",
            "type": "number"
        },
        {
            "name": "txRate",
            "baseName": "txRate",
            "type": "number"
        },
        {
            "name": "rxSignal",
            "baseName": "rxSignal",
            "type": "number"
        },
        {
            "name": "txSignal",
            "baseName": "txSignal",
            "type": "number"
        },
        {
            "name": "downlinkCapacity",
            "baseName": "downlinkCapacity",
            "type": "number"
        },
        {
            "name": "uplinkCapacity",
            "baseName": "uplinkCapacity",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Station.attributeTypeMap;
    }
}

export namespace Station {
    export enum RadioEnum {
        _24GHz = <any> '2.4GHz',
        _5GHz = <any> '5GHz'
    }
}
export class Status {
    'result'?: boolean;
    'message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "result",
            "type": "boolean"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Status.attributeTypeMap;
    }
}

export class System {
    'name'?: string;
    'timezone'?: string;
    'admin'?: any;
    /**
    * nullable string
    */
    'domainName'?: string;
    /**
    * nullable string
    */
    'gateway'?: string;
    /**
    * nullable string
    */
    'dns1'?: string;
    /**
    * nullable string
    */
    'dns2'?: string;
    'readOnlyAccount'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "timezone",
            "baseName": "timezone",
            "type": "string"
        },
        {
            "name": "admin",
            "baseName": "admin",
            "type": "any"
        },
        {
            "name": "domainName",
            "baseName": "domainName",
            "type": "string"
        },
        {
            "name": "gateway",
            "baseName": "gateway",
            "type": "string"
        },
        {
            "name": "dns1",
            "baseName": "dns1",
            "type": "string"
        },
        {
            "name": "dns2",
            "baseName": "dns2",
            "type": "string"
        },
        {
            "name": "readOnlyAccount",
            "baseName": "readOnlyAccount",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return System.attributeTypeMap;
    }
}

export class Task {
    'id'?: string;
    'type'?: Task.TypeEnum;
    'startTimestamp'?: number;
    'endTimestamp'?: number;
    'aggregatedTime'?: number;
    'status'?: Task.StatusEnum;
    'totalCount'?: number;
    'successCount'?: number;
    'taskItems'?: Array<any>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "Task.TypeEnum"
        },
        {
            "name": "startTimestamp",
            "baseName": "startTimestamp",
            "type": "number"
        },
        {
            "name": "endTimestamp",
            "baseName": "endTimestamp",
            "type": "number"
        },
        {
            "name": "aggregatedTime",
            "baseName": "aggregatedTime",
            "type": "number"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "Task.StatusEnum"
        },
        {
            "name": "totalCount",
            "baseName": "totalCount",
            "type": "number"
        },
        {
            "name": "successCount",
            "baseName": "successCount",
            "type": "number"
        },
        {
            "name": "taskItems",
            "baseName": "taskItems",
            "type": "Array<any>"
        }    ];

    static getAttributeTypeMap() {
        return Task.attributeTypeMap;
    }
}

export namespace Task {
    export enum TypeEnum {
        FWUpgrade = <any> 'FW upgrade',
        MassFWUpgrade = <any> 'Mass FW upgrade'
    }
    export enum StatusEnum {
        Success = <any> 'success',
        Failed = <any> 'failed',
        InProgress = <any> 'in-progress',
        Canceled = <any> 'canceled'
    }
}
export class TwoFactorSecret {
    /**
    * otp secret in base32 encoding
    */
    'base32'?: string;
    /**
    * otp secret url for authenticator app
    */
    'otpauthUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "base32",
            "baseName": "base32",
            "type": "string"
        },
        {
            "name": "otpauthUrl",
            "baseName": "otpauth_url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TwoFactorSecret.attributeTypeMap;
    }
}

export class TwoFactorToken {
    'id'?: string;
    'userId'?: string;
    'sessionTimeout'?: number;
    /**
    * unix timestamp in milliseconds
    */
    'exp'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "userId",
            "baseName": "userId",
            "type": "string"
        },
        {
            "name": "sessionTimeout",
            "baseName": "sessionTimeout",
            "type": "number"
        },
        {
            "name": "exp",
            "baseName": "exp",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TwoFactorToken.attributeTypeMap;
    }
}

export class UnmsSettings {
    /**
    * If true during update of unms global settings this device settings will not update if false yes
    */
    'overrideGlobal'?: boolean;
    /**
    * Address for device to ping
    */
    'devicePingAddress'?: string;
    /**
    * In miliseconds
    */
    'devicePingIntervalNormal'?: number;
    /**
    * In miliseconds
    */
    'devicePingIntervalOutage'?: number;
    /**
    * Transmission frequency with device
    */
    'deviceTransmissionProfile'?: UnmsSettings.DeviceTransmissionProfileEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "overrideGlobal",
            "baseName": "overrideGlobal",
            "type": "boolean"
        },
        {
            "name": "devicePingAddress",
            "baseName": "devicePingAddress",
            "type": "string"
        },
        {
            "name": "devicePingIntervalNormal",
            "baseName": "devicePingIntervalNormal",
            "type": "number"
        },
        {
            "name": "devicePingIntervalOutage",
            "baseName": "devicePingIntervalOutage",
            "type": "number"
        },
        {
            "name": "deviceTransmissionProfile",
            "baseName": "deviceTransmissionProfile",
            "type": "UnmsSettings.DeviceTransmissionProfileEnum"
        }    ];

    static getAttributeTypeMap() {
        return UnmsSettings.attributeTypeMap;
    }
}

export namespace UnmsSettings {
    export enum DeviceTransmissionProfileEnum {
        Minimal = <any> 'minimal',
        Low = <any> 'low',
        Medium = <any> 'medium',
        High = <any> 'high',
        Auto = <any> 'auto'
    }
}
export class User {
    'id'?: string;
    'username'?: string;
    'email'?: string;
    'alerts'?: boolean;
    'totpAuthEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "alerts",
            "baseName": "alerts",
            "type": "boolean"
        },
        {
            "name": "totpAuthEnabled",
            "baseName": "totpAuthEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return User.attributeTypeMap;
    }
}

export class UserProfile {
    'presentationMode'?: boolean;
    'lastLogItemId'?: string;
    'userId'?: string;
    'forceChangePassword'?: boolean;
    'tableConfig'?: any;
    'preferences'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "presentationMode",
            "baseName": "presentationMode",
            "type": "boolean"
        },
        {
            "name": "lastLogItemId",
            "baseName": "lastLogItemId",
            "type": "string"
        },
        {
            "name": "userId",
            "baseName": "userId",
            "type": "string"
        },
        {
            "name": "forceChangePassword",
            "baseName": "forceChangePassword",
            "type": "boolean"
        },
        {
            "name": "tableConfig",
            "baseName": "tableConfig",
            "type": "any"
        },
        {
            "name": "preferences",
            "baseName": "preferences",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return UserProfile.attributeTypeMap;
    }
}

export class WifiAuthenticationEnum {
    'PSK'?: WifiAuthenticationEnum.PSKEnum;
    'pSK2'?: WifiAuthenticationEnum.PSK2Enum;
    /**
    * Enterprise
    */
    'enterprise'?: WifiAuthenticationEnum.EnterpriseEnum;
    'none'?: WifiAuthenticationEnum.NoneEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PSK",
            "baseName": "PSK",
            "type": "WifiAuthenticationEnum.PSKEnum"
        },
        {
            "name": "pSK2",
            "baseName": "PSK2",
            "type": "WifiAuthenticationEnum.PSK2Enum"
        },
        {
            "name": "enterprise",
            "baseName": "Enterprise",
            "type": "WifiAuthenticationEnum.EnterpriseEnum"
        },
        {
            "name": "none",
            "baseName": "None",
            "type": "WifiAuthenticationEnum.NoneEnum"
        }    ];

    static getAttributeTypeMap() {
        return WifiAuthenticationEnum.attributeTypeMap;
    }
}

export namespace WifiAuthenticationEnum {
    export enum PSKEnum {
        Psk = <any> 'psk'
    }
    export enum PSK2Enum {
        Psk2 = <any> 'psk2'
    }
    export enum EnterpriseEnum {
        Ent = <any> 'ent'
    }
    export enum NoneEnum {
        None = <any> 'none'
    }
}
export class WifiSecurityEnum {
    'WEP'?: WifiSecurityEnum.WEPEnum;
    'WPA'?: WifiSecurityEnum.WPAEnum;
    'wPA2'?: WifiSecurityEnum.WPA2Enum;
    'none'?: WifiSecurityEnum.NoneEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "WEP",
            "baseName": "WEP",
            "type": "WifiSecurityEnum.WEPEnum"
        },
        {
            "name": "WPA",
            "baseName": "WPA",
            "type": "WifiSecurityEnum.WPAEnum"
        },
        {
            "name": "wPA2",
            "baseName": "WPA2",
            "type": "WifiSecurityEnum.WPA2Enum"
        },
        {
            "name": "none",
            "baseName": "None",
            "type": "WifiSecurityEnum.NoneEnum"
        }    ];

    static getAttributeTypeMap() {
        return WifiSecurityEnum.attributeTypeMap;
    }
}

export namespace WifiSecurityEnum {
    export enum WEPEnum {
        Wep = <any> 'wep'
    }
    export enum WPAEnum {
        Wpa = <any> 'wpa'
    }
    export enum WPA2Enum {
        Wpa2 = <any> 'wpa2'
    }
    export enum NoneEnum {
        None = <any> 'none'
    }
}
export class WirelessModeEnum {
    'ap'?: WirelessModeEnum.ApEnum;
    'apPtp'?: WirelessModeEnum.ApPtpEnum;
    'apPtmp'?: WirelessModeEnum.ApPtmpEnum;
    'apPtmpAirmaxMixed'?: WirelessModeEnum.ApPtmpAirmaxMixedEnum;
    'apPtmpAirmaxAc'?: WirelessModeEnum.ApPtmpAirmaxAcEnum;
    'sta'?: WirelessModeEnum.StaEnum;
    'staPtp'?: WirelessModeEnum.StaPtpEnum;
    'staPtmp'?: WirelessModeEnum.StaPtmpEnum;
    'apRep'?: WirelessModeEnum.ApRepEnum;
    'mesh'?: WirelessModeEnum.MeshEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ap",
            "baseName": "Ap",
            "type": "WirelessModeEnum.ApEnum"
        },
        {
            "name": "apPtp",
            "baseName": "ApPtp",
            "type": "WirelessModeEnum.ApPtpEnum"
        },
        {
            "name": "apPtmp",
            "baseName": "ApPtmp",
            "type": "WirelessModeEnum.ApPtmpEnum"
        },
        {
            "name": "apPtmpAirmaxMixed",
            "baseName": "ApPtmpAirmaxMixed",
            "type": "WirelessModeEnum.ApPtmpAirmaxMixedEnum"
        },
        {
            "name": "apPtmpAirmaxAc",
            "baseName": "ApPtmpAirmaxAc",
            "type": "WirelessModeEnum.ApPtmpAirmaxAcEnum"
        },
        {
            "name": "sta",
            "baseName": "Sta",
            "type": "WirelessModeEnum.StaEnum"
        },
        {
            "name": "staPtp",
            "baseName": "StaPtp",
            "type": "WirelessModeEnum.StaPtpEnum"
        },
        {
            "name": "staPtmp",
            "baseName": "StaPtmp",
            "type": "WirelessModeEnum.StaPtmpEnum"
        },
        {
            "name": "apRep",
            "baseName": "ApRep",
            "type": "WirelessModeEnum.ApRepEnum"
        },
        {
            "name": "mesh",
            "baseName": "Mesh",
            "type": "WirelessModeEnum.MeshEnum"
        }    ];

    static getAttributeTypeMap() {
        return WirelessModeEnum.attributeTypeMap;
    }
}

export namespace WirelessModeEnum {
    export enum ApEnum {
        Ap = <any> 'ap'
    }
    export enum ApPtpEnum {
        ApPtp = <any> 'ap-ptp'
    }
    export enum ApPtmpEnum {
        ApPtmp = <any> 'ap-ptmp'
    }
    export enum ApPtmpAirmaxMixedEnum {
        ApPtmpAirmaxMixed = <any> 'ap-ptmp-airmax-mixed'
    }
    export enum ApPtmpAirmaxAcEnum {
        ApPtmpAirmaxAc = <any> 'ap-ptmp-airmax-ac'
    }
    export enum StaEnum {
        Sta = <any> 'sta'
    }
    export enum StaPtpEnum {
        StaPtp = <any> 'sta-ptp'
    }
    export enum StaPtmpEnum {
        StaPtmp = <any> 'sta-ptmp'
    }
    export enum ApRepEnum {
        Aprepeater = <any> 'aprepeater'
    }
    export enum MeshEnum {
        Mesh = <any> 'mesh'
    }
}

let enumsMap: {[index: string]: any} = {
        "DHCPLease.TypeEnum": DHCPLease.TypeEnum,
        "DeviceAPSProfile.SecurityEnum": DeviceAPSProfile.SecurityEnum,
        "DeviceAPSProfile.AuthenticationEnum": DeviceAPSProfile.AuthenticationEnum,
        "DeviceIdentification.CategoryEnum": DeviceIdentification.CategoryEnum,
        "DeviceIdentification.TypeEnum": DeviceIdentification.TypeEnum,
        "DeviceOverview.StatusEnum": DeviceOverview.StatusEnum,
        "DiscoveryResult.StatusEnum": DiscoveryResult.StatusEnum,
        "FirmwareIdentification.OriginEnum": FirmwareIdentification.OriginEnum,
        "InterfaceConfig.SpeedEnum": InterfaceConfig.SpeedEnum,
        "InterfaceIdentification.TypeEnum": InterfaceIdentification.TypeEnum,
        "InterfaceStatus.StatusEnum": InterfaceStatus.StatusEnum,
        "LogItem.LevelEnum": LogItem.LevelEnum,
        "LogItem.TagsEnum": LogItem.TagsEnum,
        "MailServer.TypeEnum": MailServer.TypeEnum,
        "NetworkModeEnum.BridgeEnum": NetworkModeEnum.BridgeEnum,
        "NetworkModeEnum.RouterEnum": NetworkModeEnum.RouterEnum,
        "NmsUpdateStatus.NmsUpdateStatusEnum": NmsUpdateStatus.NmsUpdateStatusEnum,
        "OLTONUProfile.ModeEnum": OLTONUProfile.ModeEnum,
        "OLTONUProfile.LinkSpeedEnum": OLTONUProfile.LinkSpeedEnum,
        "OSPFArea.TypeEnum": OSPFArea.TypeEnum,
        "OutageItem.TypeEnum": OutageItem.TypeEnum,
        "POE.OutputEnum": POE.OutputEnum,
        "POE.CapacitiesEnum": POE.CapacitiesEnum,
        "PonAuthentication.AuthorizationTypeEnum": PonAuthentication.AuthorizationTypeEnum,
        "RouteOverview.TypeEnum": RouteOverview.TypeEnum,
        "RouteOverview.GatewayStatusEnum": RouteOverview.GatewayStatusEnum,
        "SiteIdentification.StatusEnum": SiteIdentification.StatusEnum,
        "SiteIdentification.TypeEnum": SiteIdentification.TypeEnum,
        "StaticRoute.TypeEnum": StaticRoute.TypeEnum,
        "Station.RadioEnum": Station.RadioEnum,
        "Task.TypeEnum": Task.TypeEnum,
        "Task.StatusEnum": Task.StatusEnum,
        "UnmsSettings.DeviceTransmissionProfileEnum": UnmsSettings.DeviceTransmissionProfileEnum,
        "WifiAuthenticationEnum.PSKEnum": WifiAuthenticationEnum.PSKEnum,
        "WifiAuthenticationEnum.PSK2Enum": WifiAuthenticationEnum.PSK2Enum,
        "WifiAuthenticationEnum.EnterpriseEnum": WifiAuthenticationEnum.EnterpriseEnum,
        "WifiAuthenticationEnum.NoneEnum": WifiAuthenticationEnum.NoneEnum,
        "WifiSecurityEnum.WEPEnum": WifiSecurityEnum.WEPEnum,
        "WifiSecurityEnum.WPAEnum": WifiSecurityEnum.WPAEnum,
        "WifiSecurityEnum.WPA2Enum": WifiSecurityEnum.WPA2Enum,
        "WifiSecurityEnum.NoneEnum": WifiSecurityEnum.NoneEnum,
        "WirelessModeEnum.ApEnum": WirelessModeEnum.ApEnum,
        "WirelessModeEnum.ApPtpEnum": WirelessModeEnum.ApPtpEnum,
        "WirelessModeEnum.ApPtmpEnum": WirelessModeEnum.ApPtmpEnum,
        "WirelessModeEnum.ApPtmpAirmaxMixedEnum": WirelessModeEnum.ApPtmpAirmaxMixedEnum,
        "WirelessModeEnum.ApPtmpAirmaxAcEnum": WirelessModeEnum.ApPtmpAirmaxAcEnum,
        "WirelessModeEnum.StaEnum": WirelessModeEnum.StaEnum,
        "WirelessModeEnum.StaPtpEnum": WirelessModeEnum.StaPtpEnum,
        "WirelessModeEnum.StaPtmpEnum": WirelessModeEnum.StaPtmpEnum,
        "WirelessModeEnum.ApRepEnum": WirelessModeEnum.ApRepEnum,
        "WirelessModeEnum.MeshEnum": WirelessModeEnum.MeshEnum,
}

let typeMap: {[index: string]: any} = {
    "AirCubeNetworkConfig": AirCubeNetworkConfig,
    "AirCubeStatusDetail": AirCubeStatusDetail,
    "AirCubeSystemConfig": AirCubeSystemConfig,
    "AirCubeWirelessConfig": AirCubeWirelessConfig,
    "AirMaxStatusDetail": AirMaxStatusDetail,
    "DHCPLease": DHCPLease,
    "DHCPServerConfiguration": DHCPServerConfiguration,
    "DeviceAPSProfile": DeviceAPSProfile,
    "DeviceBackup": DeviceBackup,
    "DeviceFirmware": DeviceFirmware,
    "DeviceIdentification": DeviceIdentification,
    "DeviceOverview": DeviceOverview,
    "DeviceStatistics": DeviceStatistics,
    "DeviceStatusOverview": DeviceStatusOverview,
    "DeviceUpgradeStatus": DeviceUpgradeStatus,
    "DiscoveryDevice": DiscoveryDevice,
    "DiscoveryDeviceIdentification": DiscoveryDeviceIdentification,
    "DiscoveryResult": DiscoveryResult,
    "DiscoveryResultIdentification": DiscoveryResultIdentification,
    "Enums": Enums,
    "ErouterStatusDetail": ErouterStatusDetail,
    "Firmware": Firmware,
    "FirmwareIdentification": FirmwareIdentification,
    "FirmwareSemver": FirmwareSemver,
    "GraphDataSet": GraphDataSet,
    "ImageIdentification": ImageIdentification,
    "ImageOverview": ImageOverview,
    "InterfaceAddressOverview": InterfaceAddressOverview,
    "InterfaceAddressType": InterfaceAddressType,
    "InterfaceConfig": InterfaceConfig,
    "InterfaceIdentification": InterfaceIdentification,
    "InterfaceOverview": InterfaceOverview,
    "InterfaceStatistics": InterfaceStatistics,
    "InterfaceStatus": InterfaceStatus,
    "LatestBackup": LatestBackup,
    "LogItem": LogItem,
    "Login": Login,
    "MTU": MTU,
    "MailServer": MailServer,
    "ModelError": ModelError,
    "NMSStatistics": NMSStatistics,
    "NetworkModeEnum": NetworkModeEnum,
    "NmsSettings": NmsSettings,
    "NmsSummary": NmsSummary,
    "NmsUpdateStatus": NmsUpdateStatus,
    "OLTONUProfile": OLTONUProfile,
    "OLTStatusDetail": OLTStatusDetail,
    "ONUClient": ONUClient,
    "ONUStatusOverview": ONUStatusOverview,
    "OSPFArea": OSPFArea,
    "OSPFAuthorization": OSPFAuthorization,
    "OSPFConfig": OSPFConfig,
    "OSPFInterface": OSPFInterface,
    "OutageItem": OutageItem,
    "POE": POE,
    "PPPOEID": PPPOEID,
    "PonAuthentication": PonAuthentication,
    "RouteOverview": RouteOverview,
    "Services": Services,
    "SiteDescription": SiteDescription,
    "SiteIdentification": SiteIdentification,
    "SiteOverview": SiteOverview,
    "SshCredentials": SshCredentials,
    "StaticRoute": StaticRoute,
    "Station": Station,
    "Status": Status,
    "System": System,
    "Task": Task,
    "TwoFactorSecret": TwoFactorSecret,
    "TwoFactorToken": TwoFactorToken,
    "UnmsSettings": UnmsSettings,
    "User": User,
    "UserProfile": UserProfile,
    "WifiAuthenticationEnum": WifiAuthenticationEnum,
    "WifiSecurityEnum": WifiSecurityEnum,
    "WirelessModeEnum": WirelessModeEnum,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum DevicesApiApiKeys {
    UserSecurity,
}

export class DevicesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'UserSecurity': new ApiKeyAuth('header', 'x-auth-token'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DevicesApiApiKeys, value: string) {
        (this.authentications as any)[DevicesApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Get AirCube network config
     * @param xAuthToken User authorization token
     * @param id device ID
     * @param {*} [options] Override http request options.
     */
    public devicesAircubesIdConfigNetworkGet (xAuthToken: string, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: AirCubeNetworkConfig;  }> {
        const localVarPath = this.basePath + '/devices/aircubes/{id}/config/network'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesAircubesIdConfigNetworkGet.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesAircubesIdConfigNetworkGet.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AirCubeNetworkConfig;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AirCubeNetworkConfig");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update AirCube network config
     * @param xAuthToken User authorization token
     * @param id device ID
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public devicesAircubesIdConfigNetworkPut (xAuthToken: string, id: string, body: AirCubeNetworkConfig, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/devices/aircubes/{id}/config/network'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesAircubesIdConfigNetworkPut.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesAircubesIdConfigNetworkPut.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling devicesAircubesIdConfigNetworkPut.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "AirCubeNetworkConfig")
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get AirCube system config
     * @param xAuthToken User authorization token
     * @param id device ID
     * @param {*} [options] Override http request options.
     */
    public devicesAircubesIdConfigSystemGet (xAuthToken: string, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: AirCubeSystemConfig;  }> {
        const localVarPath = this.basePath + '/devices/aircubes/{id}/config/system'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesAircubesIdConfigSystemGet.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesAircubesIdConfigSystemGet.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AirCubeSystemConfig;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AirCubeSystemConfig");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update AirCube system config
     * @param xAuthToken User authorization token
     * @param id device ID
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public devicesAircubesIdConfigSystemPut (xAuthToken: string, id: string, body: AirCubeSystemConfig, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/devices/aircubes/{id}/config/system'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesAircubesIdConfigSystemPut.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesAircubesIdConfigSystemPut.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling devicesAircubesIdConfigSystemPut.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "AirCubeSystemConfig")
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update AirCube wireless config
     * @param xAuthToken User authorization token
     * @param id device ID
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public devicesAircubesIdConfigWirelessPut (xAuthToken: string, id: string, body: Body, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/devices/aircubes/{id}/config/wireless'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesAircubesIdConfigWirelessPut.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesAircubesIdConfigWirelessPut.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling devicesAircubesIdConfigWirelessPut.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Body")
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Return AirCube frequency lists
     * @param xAuthToken User authorization token
     * @param id device ID
     * @param {*} [options] Override http request options.
     */
    public devicesAircubesIdFrequencyListsGet (xAuthToken: string, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/devices/aircubes/{id}/frequency-lists'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesAircubesIdFrequencyListsGet.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesAircubesIdFrequencyListsGet.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Return AirCube detail
     * @param xAuthToken User authorization token
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public devicesAircubesIdGet (xAuthToken: string, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: AirCubeStatusDetail;  }> {
        const localVarPath = this.basePath + '/devices/aircubes/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesAircubesIdGet.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesAircubesIdGet.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AirCubeStatusDetail;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AirCubeStatusDetail");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Return AirCube station list
     * @param xAuthToken User authorization token
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public devicesAircubesIdStationsGet (xAuthToken: string, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Station>;  }> {
        const localVarPath = this.basePath + '/devices/aircubes/{id}/stations'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesAircubesIdStationsGet.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesAircubesIdStationsGet.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Station>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Station>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Return AirMax detail
     * @param xAuthToken User authorization token
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public devicesAirmaxesIdGet (xAuthToken: string, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: AirMaxStatusDetail;  }> {
        const localVarPath = this.basePath + '/devices/airmaxes/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesAirmaxesIdGet.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesAirmaxesIdGet.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AirMaxStatusDetail;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AirMaxStatusDetail");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List of all access points connection profiles
     * @param xAuthToken User authorization token
     * @param {*} [options] Override http request options.
     */
    public devicesApsProfilesGet (xAuthToken: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<DeviceAPSProfile>;  }> {
        const localVarPath = this.basePath + '/devices/aps/profiles';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesApsProfilesGet.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<DeviceAPSProfile>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<DeviceAPSProfile>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create and download a new multi device backup
     * @param xAuthToken User authorization token
     * @param payload 
     * @param {*} [options] Override http request options.
     */
    public devicesBackupsPost (xAuthToken: string, payload: Payload, options: any = {}) : Promise<{ response: http.ClientResponse; body: Buffer;  }> {
        const localVarPath = this.basePath + '/devices/backups';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesBackupsPost.');
        }

        // verify required parameter 'payload' is not null or undefined
        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling devicesBackupsPost.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
            body: ObjectSerializer.serialize(payload, "Payload")
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Buffer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update device configuration from backup file
     * @param xAuthToken User authorization token
     * @param deviceId 
     * @param backupId 
     * @param {*} [options] Override http request options.
     */
    public devicesDeviceIdBackupsBackupIdApplyPost (xAuthToken: string, deviceId: string, backupId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/devices/{deviceId}/backups/{backupId}/apply'
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)))
            .replace('{' + 'backupId' + '}', encodeURIComponent(String(backupId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesDeviceIdBackupsBackupIdApplyPost.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling devicesDeviceIdBackupsBackupIdApplyPost.');
        }

        // verify required parameter 'backupId' is not null or undefined
        if (backupId === null || backupId === undefined) {
            throw new Error('Required parameter backupId was null or undefined when calling devicesDeviceIdBackupsBackupIdApplyPost.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete backup
     * @param xAuthToken User authorization token
     * @param deviceId 
     * @param backupId 
     * @param {*} [options] Override http request options.
     */
    public devicesDeviceIdBackupsBackupIdDelete (xAuthToken: string, deviceId: string, backupId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/devices/{deviceId}/backups/{backupId}'
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)))
            .replace('{' + 'backupId' + '}', encodeURIComponent(String(backupId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesDeviceIdBackupsBackupIdDelete.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling devicesDeviceIdBackupsBackupIdDelete.');
        }

        // verify required parameter 'backupId' is not null or undefined
        if (backupId === null || backupId === undefined) {
            throw new Error('Required parameter backupId was null or undefined when calling devicesDeviceIdBackupsBackupIdDelete.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Return device configuration backup file
     * @param xAuthToken User authorization token
     * @param deviceId 
     * @param backupId 
     * @param replaceUnmsKey 
     * @param {*} [options] Override http request options.
     */
    public devicesDeviceIdBackupsBackupIdGet (xAuthToken: string, deviceId: string, backupId: string, replaceUnmsKey?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: Buffer;  }> {
        const localVarPath = this.basePath + '/devices/{deviceId}/backups/{backupId}'
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)))
            .replace('{' + 'backupId' + '}', encodeURIComponent(String(backupId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesDeviceIdBackupsBackupIdGet.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling devicesDeviceIdBackupsBackupIdGet.');
        }

        // verify required parameter 'backupId' is not null or undefined
        if (backupId === null || backupId === undefined) {
            throw new Error('Required parameter backupId was null or undefined when calling devicesDeviceIdBackupsBackupIdGet.');
        }

        if (replaceUnmsKey !== undefined) {
            localVarQueryParameters['replaceUnmsKey'] = ObjectSerializer.serialize(replaceUnmsKey, "boolean");
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Buffer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Return list of device interfaces
     * @param xAuthToken User authorization token
     * @param deviceId 
     * @param {*} [options] Override http request options.
     */
    public devicesDeviceIdInterfacesGet (xAuthToken: string, deviceId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<InterfaceOverview>;  }> {
        const localVarPath = this.basePath + '/devices/{deviceId}/interfaces'
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesDeviceIdInterfacesGet.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling devicesDeviceIdInterfacesGet.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<InterfaceOverview>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<InterfaceOverview>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Block interface
     * @param xAuthToken 
     * @param deviceId 
     * @param interfaceName 
     * @param {*} [options] Override http request options.
     */
    public devicesDeviceIdInterfacesInterfaceNameBlockPost (xAuthToken: string, deviceId: string, interfaceName: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/devices/{deviceId}/interfaces/{interfaceName}/block'
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)))
            .replace('{' + 'interfaceName' + '}', encodeURIComponent(String(interfaceName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesDeviceIdInterfacesInterfaceNameBlockPost.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling devicesDeviceIdInterfacesInterfaceNameBlockPost.');
        }

        // verify required parameter 'interfaceName' is not null or undefined
        if (interfaceName === null || interfaceName === undefined) {
            throw new Error('Required parameter interfaceName was null or undefined when calling devicesDeviceIdInterfacesInterfaceNameBlockPost.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete interface
     * @param xAuthToken User authorization token
     * @param deviceId 
     * @param interfaceName 
     * @param {*} [options] Override http request options.
     */
    public devicesDeviceIdInterfacesInterfaceNameDelete (xAuthToken: string, deviceId: string, interfaceName: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/devices/{deviceId}/interfaces/{interfaceName}'
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)))
            .replace('{' + 'interfaceName' + '}', encodeURIComponent(String(interfaceName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesDeviceIdInterfacesInterfaceNameDelete.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling devicesDeviceIdInterfacesInterfaceNameDelete.');
        }

        // verify required parameter 'interfaceName' is not null or undefined
        if (interfaceName === null || interfaceName === undefined) {
            throw new Error('Required parameter interfaceName was null or undefined when calling devicesDeviceIdInterfacesInterfaceNameDelete.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get interface configuration
     * @param xAuthToken User authorization token
     * @param deviceId 
     * @param interfaceName 
     * @param {*} [options] Override http request options.
     */
    public devicesDeviceIdInterfacesInterfaceNameGet (xAuthToken: string, deviceId: string, interfaceName: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: InterfaceConfig;  }> {
        const localVarPath = this.basePath + '/devices/{deviceId}/interfaces/{interfaceName}'
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)))
            .replace('{' + 'interfaceName' + '}', encodeURIComponent(String(interfaceName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesDeviceIdInterfacesInterfaceNameGet.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling devicesDeviceIdInterfacesInterfaceNameGet.');
        }

        // verify required parameter 'interfaceName' is not null or undefined
        if (interfaceName === null || interfaceName === undefined) {
            throw new Error('Required parameter interfaceName was null or undefined when calling devicesDeviceIdInterfacesInterfaceNameGet.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InterfaceConfig;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InterfaceConfig");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Unset interface OSPF config
     * @param xAuthToken 
     * @param deviceId 
     * @param interfaceName 
     * @param {*} [options] Override http request options.
     */
    public devicesDeviceIdInterfacesInterfaceNameOspfDelete (xAuthToken: string, deviceId: string, interfaceName: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/devices/{deviceId}/interfaces/{interfaceName}/ospf'
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)))
            .replace('{' + 'interfaceName' + '}', encodeURIComponent(String(interfaceName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesDeviceIdInterfacesInterfaceNameOspfDelete.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling devicesDeviceIdInterfacesInterfaceNameOspfDelete.');
        }

        // verify required parameter 'interfaceName' is not null or undefined
        if (interfaceName === null || interfaceName === undefined) {
            throw new Error('Required parameter interfaceName was null or undefined when calling devicesDeviceIdInterfacesInterfaceNameOspfDelete.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set interface OSPF config
     * @param xAuthToken 
     * @param deviceId 
     * @param interfaceName 
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public devicesDeviceIdInterfacesInterfaceNameOspfPut (xAuthToken: string, deviceId: string, interfaceName: string, body?: OSPFInterface, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/devices/{deviceId}/interfaces/{interfaceName}/ospf'
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)))
            .replace('{' + 'interfaceName' + '}', encodeURIComponent(String(interfaceName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesDeviceIdInterfacesInterfaceNameOspfPut.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling devicesDeviceIdInterfacesInterfaceNameOspfPut.');
        }

        // verify required parameter 'interfaceName' is not null or undefined
        if (interfaceName === null || interfaceName === undefined) {
            throw new Error('Required parameter interfaceName was null or undefined when calling devicesDeviceIdInterfacesInterfaceNameOspfPut.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "OSPFInterface")
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update interface configuration
     * @param xAuthToken User authorization token
     * @param deviceId 
     * @param interfaceName 
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public devicesDeviceIdInterfacesInterfaceNamePut (xAuthToken: string, deviceId: string, interfaceName: string, body: InterfaceConfig, options: any = {}) : Promise<{ response: http.ClientResponse; body: InterfaceConfig;  }> {
        const localVarPath = this.basePath + '/devices/{deviceId}/interfaces/{interfaceName}'
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)))
            .replace('{' + 'interfaceName' + '}', encodeURIComponent(String(interfaceName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesDeviceIdInterfacesInterfaceNamePut.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling devicesDeviceIdInterfacesInterfaceNamePut.');
        }

        // verify required parameter 'interfaceName' is not null or undefined
        if (interfaceName === null || interfaceName === undefined) {
            throw new Error('Required parameter interfaceName was null or undefined when calling devicesDeviceIdInterfacesInterfaceNamePut.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling devicesDeviceIdInterfacesInterfaceNamePut.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "InterfaceConfig")
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InterfaceConfig;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InterfaceConfig");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Reset interface statistics
     * @param xAuthToken 
     * @param deviceId 
     * @param interfaceName 
     * @param {*} [options] Override http request options.
     */
    public devicesDeviceIdInterfacesInterfaceNameResetstatsPost (xAuthToken: string, deviceId: string, interfaceName: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/devices/{deviceId}/interfaces/{interfaceName}/resetstats'
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)))
            .replace('{' + 'interfaceName' + '}', encodeURIComponent(String(interfaceName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesDeviceIdInterfacesInterfaceNameResetstatsPost.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling devicesDeviceIdInterfacesInterfaceNameResetstatsPost.');
        }

        // verify required parameter 'interfaceName' is not null or undefined
        if (interfaceName === null || interfaceName === undefined) {
            throw new Error('Required parameter interfaceName was null or undefined when calling devicesDeviceIdInterfacesInterfaceNameResetstatsPost.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Unblock interface
     * @param xAuthToken 
     * @param deviceId 
     * @param interfaceName 
     * @param {*} [options] Override http request options.
     */
    public devicesDeviceIdInterfacesInterfaceNameUnblockPost (xAuthToken: string, deviceId: string, interfaceName: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/devices/{deviceId}/interfaces/{interfaceName}/unblock'
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)))
            .replace('{' + 'interfaceName' + '}', encodeURIComponent(String(interfaceName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesDeviceIdInterfacesInterfaceNameUnblockPost.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling devicesDeviceIdInterfacesInterfaceNameUnblockPost.');
        }

        // verify required parameter 'interfaceName' is not null or undefined
        if (interfaceName === null || interfaceName === undefined) {
            throw new Error('Required parameter interfaceName was null or undefined when calling devicesDeviceIdInterfacesInterfaceNameUnblockPost.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create new pppoe interface
     * @param xAuthToken User authorization token
     * @param deviceId 
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public devicesDeviceIdInterfacesPppoePost (xAuthToken: string, deviceId: string, body: Body, options: any = {}) : Promise<{ response: http.ClientResponse; body: InterfaceConfig;  }> {
        const localVarPath = this.basePath + '/devices/{deviceId}/interfaces/pppoe'
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesDeviceIdInterfacesPppoePost.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling devicesDeviceIdInterfacesPppoePost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling devicesDeviceIdInterfacesPppoePost.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Body")
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InterfaceConfig;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InterfaceConfig");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create new vlan interface
     * @param xAuthToken User authorization token
     * @param deviceId 
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public devicesDeviceIdInterfacesVlanPost (xAuthToken: string, deviceId: string, body: Body, options: any = {}) : Promise<{ response: http.ClientResponse; body: InterfaceConfig;  }> {
        const localVarPath = this.basePath + '/devices/{deviceId}/interfaces/vlan'
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesDeviceIdInterfacesVlanPost.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling devicesDeviceIdInterfacesVlanPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling devicesDeviceIdInterfacesVlanPost.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Body")
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InterfaceConfig;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InterfaceConfig");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Device services
     * @param xAuthToken User authorization token
     * @param deviceId 
     * @param {*} [options] Override http request options.
     */
    public devicesDeviceIdServicesGet (xAuthToken: string, deviceId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Services>;  }> {
        const localVarPath = this.basePath + '/devices/{deviceId}/services'
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesDeviceIdServicesGet.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling devicesDeviceIdServicesGet.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Services>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Services>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update device services
     * @param xAuthToken User authorization token
     * @param deviceId 
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public devicesDeviceIdServicesPut (xAuthToken: string, deviceId: string, body: Services, options: any = {}) : Promise<{ response: http.ClientResponse; body: Services;  }> {
        const localVarPath = this.basePath + '/devices/{deviceId}/services'
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesDeviceIdServicesPut.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling devicesDeviceIdServicesPut.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling devicesDeviceIdServicesPut.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Services")
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Services;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Services");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Device system configuration
     * @param xAuthToken User authorization token
     * @param deviceId 
     * @param {*} [options] Override http request options.
     */
    public devicesDeviceIdSystemGet (xAuthToken: string, deviceId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<System>;  }> {
        const localVarPath = this.basePath + '/devices/{deviceId}/system'
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesDeviceIdSystemGet.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling devicesDeviceIdSystemGet.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<System>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<System>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update device system configuration
     * @param xAuthToken User authorization token
     * @param deviceId 
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public devicesDeviceIdSystemPut (xAuthToken: string, deviceId: string, body: System, options: any = {}) : Promise<{ response: http.ClientResponse; body: System;  }> {
        const localVarPath = this.basePath + '/devices/{deviceId}/system'
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesDeviceIdSystemPut.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling devicesDeviceIdSystemPut.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling devicesDeviceIdSystemPut.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "System")
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: System;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "System");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Device specific UNMS settings
     * @param xAuthToken User authorization token
     * @param deviceId 
     * @param {*} [options] Override http request options.
     */
    public devicesDeviceIdSystemUnmsGet (xAuthToken: string, deviceId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: UnmsSettings;  }> {
        const localVarPath = this.basePath + '/devices/{deviceId}/system/unms'
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesDeviceIdSystemUnmsGet.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling devicesDeviceIdSystemUnmsGet.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UnmsSettings;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UnmsSettings");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update device specific unms settings
     * @param xAuthToken User authorization token
     * @param deviceId 
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public devicesDeviceIdSystemUnmsPut (xAuthToken: string, deviceId: string, body: UnmsSettings, options: any = {}) : Promise<{ response: http.ClientResponse; body: UnmsSettings;  }> {
        const localVarPath = this.basePath + '/devices/{deviceId}/system/unms'
            .replace('{' + 'deviceId' + '}', encodeURIComponent(String(deviceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesDeviceIdSystemUnmsPut.');
        }

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling devicesDeviceIdSystemUnmsPut.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling devicesDeviceIdSystemUnmsPut.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "UnmsSettings")
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UnmsSettings;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UnmsSettings");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param xAuthToken User authorization token
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public devicesEroutersIdDelete (xAuthToken: string, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/devices/erouters/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesEroutersIdDelete.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesEroutersIdDelete.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary DHCP IP address leases
     * @param xAuthToken User authorization token
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public devicesEroutersIdDhcpLeasesGet (xAuthToken: string, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<DHCPLease>;  }> {
        const localVarPath = this.basePath + '/devices/erouters/{id}/dhcp/leases'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesEroutersIdDhcpLeasesGet.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesEroutersIdDhcpLeasesGet.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<DHCPLease>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<DHCPLease>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create DHCP IP address lease
     * @param xAuthToken User authorization token
     * @param id 
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public devicesEroutersIdDhcpLeasesPost (xAuthToken: string, id: string, body: Body, options: any = {}) : Promise<{ response: http.ClientResponse; body: DHCPLease;  }> {
        const localVarPath = this.basePath + '/devices/erouters/{id}/dhcp/leases'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesEroutersIdDhcpLeasesPost.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesEroutersIdDhcpLeasesPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling devicesEroutersIdDhcpLeasesPost.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Body")
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DHCPLease;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DHCPLease");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete DHCP IP lease
     * @param xAuthToken User authorization token
     * @param id 
     * @param serverName 
     * @param leaseId 
     * @param {*} [options] Override http request options.
     */
    public devicesEroutersIdDhcpLeasesServerNameLeaseIdDelete (xAuthToken: string, id: string, serverName: string, leaseId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/devices/erouters/{id}/dhcp/leases/{serverName}/{leaseId}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)))
            .replace('{' + 'serverName' + '}', encodeURIComponent(String(serverName)))
            .replace('{' + 'leaseId' + '}', encodeURIComponent(String(leaseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesEroutersIdDhcpLeasesServerNameLeaseIdDelete.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesEroutersIdDhcpLeasesServerNameLeaseIdDelete.');
        }

        // verify required parameter 'serverName' is not null or undefined
        if (serverName === null || serverName === undefined) {
            throw new Error('Required parameter serverName was null or undefined when calling devicesEroutersIdDhcpLeasesServerNameLeaseIdDelete.');
        }

        // verify required parameter 'leaseId' is not null or undefined
        if (leaseId === null || leaseId === undefined) {
            throw new Error('Required parameter leaseId was null or undefined when calling devicesEroutersIdDhcpLeasesServerNameLeaseIdDelete.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update DHCP IP lease
     * @param xAuthToken User authorization token
     * @param id 
     * @param serverName 
     * @param leaseId 
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public devicesEroutersIdDhcpLeasesServerNameLeaseIdPut (xAuthToken: string, id: string, serverName: string, leaseId: string, body: DHCPLease, options: any = {}) : Promise<{ response: http.ClientResponse; body: DHCPLease;  }> {
        const localVarPath = this.basePath + '/devices/erouters/{id}/dhcp/leases/{serverName}/{leaseId}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)))
            .replace('{' + 'serverName' + '}', encodeURIComponent(String(serverName)))
            .replace('{' + 'leaseId' + '}', encodeURIComponent(String(leaseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesEroutersIdDhcpLeasesServerNameLeaseIdPut.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesEroutersIdDhcpLeasesServerNameLeaseIdPut.');
        }

        // verify required parameter 'serverName' is not null or undefined
        if (serverName === null || serverName === undefined) {
            throw new Error('Required parameter serverName was null or undefined when calling devicesEroutersIdDhcpLeasesServerNameLeaseIdPut.');
        }

        // verify required parameter 'leaseId' is not null or undefined
        if (leaseId === null || leaseId === undefined) {
            throw new Error('Required parameter leaseId was null or undefined when calling devicesEroutersIdDhcpLeasesServerNameLeaseIdPut.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling devicesEroutersIdDhcpLeasesServerNameLeaseIdPut.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "DHCPLease")
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DHCPLease;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DHCPLease");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Device DHCP servers
     * @param xAuthToken User authorization token
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public devicesEroutersIdDhcpServersGet (xAuthToken: string, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<DHCPServerConfiguration>;  }> {
        const localVarPath = this.basePath + '/devices/erouters/{id}/dhcp/servers'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesEroutersIdDhcpServersGet.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesEroutersIdDhcpServersGet.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<DHCPServerConfiguration>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<DHCPServerConfiguration>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create new DHCP server
     * @param xAuthToken User authorization token
     * @param id 
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public devicesEroutersIdDhcpServersPost (xAuthToken: string, id: string, body: DHCPServerConfiguration, options: any = {}) : Promise<{ response: http.ClientResponse; body: DHCPServerConfiguration;  }> {
        const localVarPath = this.basePath + '/devices/erouters/{id}/dhcp/servers'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesEroutersIdDhcpServersPost.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesEroutersIdDhcpServersPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling devicesEroutersIdDhcpServersPost.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "DHCPServerConfiguration")
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DHCPServerConfiguration;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DHCPServerConfiguration");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Block DHCP server
     * @param xAuthToken 
     * @param id 
     * @param serverName 
     * @param {*} [options] Override http request options.
     */
    public devicesEroutersIdDhcpServersServerNameBlockPost (xAuthToken: string, id: string, serverName: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/devices/erouters/{id}/dhcp/servers/{serverName}/block'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)))
            .replace('{' + 'serverName' + '}', encodeURIComponent(String(serverName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesEroutersIdDhcpServersServerNameBlockPost.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesEroutersIdDhcpServersServerNameBlockPost.');
        }

        // verify required parameter 'serverName' is not null or undefined
        if (serverName === null || serverName === undefined) {
            throw new Error('Required parameter serverName was null or undefined when calling devicesEroutersIdDhcpServersServerNameBlockPost.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete DHCP server
     * @param xAuthToken User authorization token
     * @param id 
     * @param serverName 
     * @param {*} [options] Override http request options.
     */
    public devicesEroutersIdDhcpServersServerNameDelete (xAuthToken: string, id: string, serverName: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/devices/erouters/{id}/dhcp/servers/{serverName}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)))
            .replace('{' + 'serverName' + '}', encodeURIComponent(String(serverName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesEroutersIdDhcpServersServerNameDelete.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesEroutersIdDhcpServersServerNameDelete.');
        }

        // verify required parameter 'serverName' is not null or undefined
        if (serverName === null || serverName === undefined) {
            throw new Error('Required parameter serverName was null or undefined when calling devicesEroutersIdDhcpServersServerNameDelete.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get DHCP server configuration
     * @param xAuthToken User authorization token
     * @param id 
     * @param serverName 
     * @param {*} [options] Override http request options.
     */
    public devicesEroutersIdDhcpServersServerNameGet (xAuthToken: string, id: string, serverName: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: DHCPServerConfiguration;  }> {
        const localVarPath = this.basePath + '/devices/erouters/{id}/dhcp/servers/{serverName}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)))
            .replace('{' + 'serverName' + '}', encodeURIComponent(String(serverName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesEroutersIdDhcpServersServerNameGet.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesEroutersIdDhcpServersServerNameGet.');
        }

        // verify required parameter 'serverName' is not null or undefined
        if (serverName === null || serverName === undefined) {
            throw new Error('Required parameter serverName was null or undefined when calling devicesEroutersIdDhcpServersServerNameGet.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DHCPServerConfiguration;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DHCPServerConfiguration");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update DHCP server configuration
     * @param xAuthToken User authorization token
     * @param id 
     * @param serverName 
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public devicesEroutersIdDhcpServersServerNamePut (xAuthToken: string, id: string, serverName: string, body: DHCPServerConfiguration, options: any = {}) : Promise<{ response: http.ClientResponse; body: DHCPServerConfiguration;  }> {
        const localVarPath = this.basePath + '/devices/erouters/{id}/dhcp/servers/{serverName}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)))
            .replace('{' + 'serverName' + '}', encodeURIComponent(String(serverName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesEroutersIdDhcpServersServerNamePut.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesEroutersIdDhcpServersServerNamePut.');
        }

        // verify required parameter 'serverName' is not null or undefined
        if (serverName === null || serverName === undefined) {
            throw new Error('Required parameter serverName was null or undefined when calling devicesEroutersIdDhcpServersServerNamePut.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling devicesEroutersIdDhcpServersServerNamePut.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "DHCPServerConfiguration")
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DHCPServerConfiguration;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DHCPServerConfiguration");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Unblock dhcp server
     * @param xAuthToken 
     * @param id 
     * @param serverName 
     * @param {*} [options] Override http request options.
     */
    public devicesEroutersIdDhcpServersServerNameUnblockPost (xAuthToken: string, id: string, serverName: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/devices/erouters/{id}/dhcp/servers/{serverName}/unblock'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)))
            .replace('{' + 'serverName' + '}', encodeURIComponent(String(serverName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesEroutersIdDhcpServersServerNameUnblockPost.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesEroutersIdDhcpServersServerNameUnblockPost.');
        }

        // verify required parameter 'serverName' is not null or undefined
        if (serverName === null || serverName === undefined) {
            throw new Error('Required parameter serverName was null or undefined when calling devicesEroutersIdDhcpServersServerNameUnblockPost.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Return erouter detail
     * @param xAuthToken User authorization token
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public devicesEroutersIdGet (xAuthToken: string, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ErouterStatusDetail;  }> {
        const localVarPath = this.basePath + '/devices/erouters/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesEroutersIdGet.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesEroutersIdGet.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ErouterStatusDetail;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ErouterStatusDetail");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete OSPF area
     * @param xAuthToken User authorization token
     * @param id 
     * @param area 
     * @param {*} [options] Override http request options.
     */
    public devicesEroutersIdRouterOspfAreasAreaDelete (xAuthToken: string, id: string, area: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/devices/erouters/{id}/router/ospf/areas/{area}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)))
            .replace('{' + 'area' + '}', encodeURIComponent(String(area)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesEroutersIdRouterOspfAreasAreaDelete.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesEroutersIdRouterOspfAreasAreaDelete.');
        }

        // verify required parameter 'area' is not null or undefined
        if (area === null || area === undefined) {
            throw new Error('Required parameter area was null or undefined when calling devicesEroutersIdRouterOspfAreasAreaDelete.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update OSPF area
     * @param xAuthToken User authorization token
     * @param id 
     * @param area 
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public devicesEroutersIdRouterOspfAreasAreaPut (xAuthToken: string, id: string, area: string, body: OSPFArea, options: any = {}) : Promise<{ response: http.ClientResponse; body: OSPFArea;  }> {
        const localVarPath = this.basePath + '/devices/erouters/{id}/router/ospf/areas/{area}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)))
            .replace('{' + 'area' + '}', encodeURIComponent(String(area)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesEroutersIdRouterOspfAreasAreaPut.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesEroutersIdRouterOspfAreasAreaPut.');
        }

        // verify required parameter 'area' is not null or undefined
        if (area === null || area === undefined) {
            throw new Error('Required parameter area was null or undefined when calling devicesEroutersIdRouterOspfAreasAreaPut.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling devicesEroutersIdRouterOspfAreasAreaPut.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "OSPFArea")
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OSPFArea;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "OSPFArea");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary All OSPF areas
     * @param xAuthToken User authorization token
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public devicesEroutersIdRouterOspfAreasGet (xAuthToken: string, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<OSPFArea>;  }> {
        const localVarPath = this.basePath + '/devices/erouters/{id}/router/ospf/areas'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesEroutersIdRouterOspfAreasGet.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesEroutersIdRouterOspfAreasGet.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<OSPFArea>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<OSPFArea>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create new OSPF area
     * @param xAuthToken User authorization token
     * @param id 
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public devicesEroutersIdRouterOspfAreasPost (xAuthToken: string, id: string, body: OSPFArea, options: any = {}) : Promise<{ response: http.ClientResponse; body: OSPFArea;  }> {
        const localVarPath = this.basePath + '/devices/erouters/{id}/router/ospf/areas'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesEroutersIdRouterOspfAreasPost.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesEroutersIdRouterOspfAreasPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling devicesEroutersIdRouterOspfAreasPost.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "OSPFArea")
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OSPFArea;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "OSPFArea");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get OSPF configuration
     * @param xAuthToken User authorization token
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public devicesEroutersIdRouterOspfGet (xAuthToken: string, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: OSPFConfig;  }> {
        const localVarPath = this.basePath + '/devices/erouters/{id}/router/ospf'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesEroutersIdRouterOspfGet.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesEroutersIdRouterOspfGet.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OSPFConfig;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "OSPFConfig");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update OSPF configuration
     * @param xAuthToken User authorization token
     * @param id 
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public devicesEroutersIdRouterOspfPut (xAuthToken: string, id: string, body: OSPFConfig, options: any = {}) : Promise<{ response: http.ClientResponse; body: OSPFConfig;  }> {
        const localVarPath = this.basePath + '/devices/erouters/{id}/router/ospf'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesEroutersIdRouterOspfPut.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesEroutersIdRouterOspfPut.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling devicesEroutersIdRouterOspfPut.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "OSPFConfig")
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OSPFConfig;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "OSPFConfig");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Edit static route
     * @param xAuthToken User authorization token
     * @param id 
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public devicesEroutersIdRouterRoutesBlockPost (xAuthToken: string, id: string, body: StaticRoute, options: any = {}) : Promise<{ response: http.ClientResponse; body: RouteOverview;  }> {
        const localVarPath = this.basePath + '/devices/erouters/{id}/router/routes/block'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesEroutersIdRouterRoutesBlockPost.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesEroutersIdRouterRoutesBlockPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling devicesEroutersIdRouterRoutesBlockPost.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "StaticRoute")
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RouteOverview;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RouteOverview");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete route
     * @param xAuthToken User authorization token
     * @param id 
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public devicesEroutersIdRouterRoutesDeletePost (xAuthToken: string, id: string, body: StaticRoute, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/devices/erouters/{id}/router/routes/delete'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesEroutersIdRouterRoutesDeletePost.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesEroutersIdRouterRoutesDeletePost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling devicesEroutersIdRouterRoutesDeletePost.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "StaticRoute")
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary All routes
     * @param xAuthToken User authorization token
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public devicesEroutersIdRouterRoutesGet (xAuthToken: string, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<RouteOverview>;  }> {
        const localVarPath = this.basePath + '/devices/erouters/{id}/router/routes'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesEroutersIdRouterRoutesGet.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesEroutersIdRouterRoutesGet.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<RouteOverview>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<RouteOverview>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create new static route
     * @param xAuthToken User authorization token
     * @param id 
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public devicesEroutersIdRouterRoutesPost (xAuthToken: string, id: string, body: StaticRoute, options: any = {}) : Promise<{ response: http.ClientResponse; body: RouteOverview;  }> {
        const localVarPath = this.basePath + '/devices/erouters/{id}/router/routes'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesEroutersIdRouterRoutesPost.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesEroutersIdRouterRoutesPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling devicesEroutersIdRouterRoutesPost.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "StaticRoute")
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RouteOverview;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RouteOverview");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Edit static route
     * @param xAuthToken User authorization token
     * @param id 
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public devicesEroutersIdRouterRoutesPut (xAuthToken: string, id: string, body: StaticRoute, options: any = {}) : Promise<{ response: http.ClientResponse; body: RouteOverview;  }> {
        const localVarPath = this.basePath + '/devices/erouters/{id}/router/routes'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesEroutersIdRouterRoutesPut.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesEroutersIdRouterRoutesPut.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling devicesEroutersIdRouterRoutesPut.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "StaticRoute")
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RouteOverview;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RouteOverview");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Edit static route
     * @param xAuthToken User authorization token
     * @param id 
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public devicesEroutersIdRouterRoutesUnblockPost (xAuthToken: string, id: string, body: StaticRoute, options: any = {}) : Promise<{ response: http.ClientResponse; body: RouteOverview;  }> {
        const localVarPath = this.basePath + '/devices/erouters/{id}/router/routes/unblock'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesEroutersIdRouterRoutesUnblockPost.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesEroutersIdRouterRoutesUnblockPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling devicesEroutersIdRouterRoutesUnblockPost.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "StaticRoute")
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RouteOverview;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RouteOverview");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List of all devices in network
     * @param xAuthToken User authorization token
     * @param siteId 
     * @param parentId 
     * @param {*} [options] Override http request options.
     */
    public devicesGet (xAuthToken: string, siteId?: string, parentId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<DeviceStatusOverview>;  }> {
        const localVarPath = this.basePath + '/devices';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesGet.');
        }

        if (siteId !== undefined) {
            localVarQueryParameters['siteId'] = ObjectSerializer.serialize(siteId, "string");
        }

        if (parentId !== undefined) {
            localVarQueryParameters['parentId'] = ObjectSerializer.serialize(parentId, "string");
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<DeviceStatusOverview>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<DeviceStatusOverview>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Authorize device
     * @param xAuthToken User authorization token
     * @param id 
     * @param payload 
     * @param {*} [options] Override http request options.
     */
    public devicesIdAuthorizePost (xAuthToken: string, id: string, payload: Payload, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/devices/{id}/authorize'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesIdAuthorizePost.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesIdAuthorizePost.');
        }

        // verify required parameter 'payload' is not null or undefined
        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling devicesIdAuthorizePost.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(payload, "Payload")
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Return list of device backups
     * @param xAuthToken User authorization token
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public devicesIdBackupsGet (xAuthToken: string, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<DeviceBackup>;  }> {
        const localVarPath = this.basePath + '/devices/{id}/backups'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesIdBackupsGet.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesIdBackupsGet.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<DeviceBackup>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<DeviceBackup>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create new device backup
     * @param xAuthToken User authorization token
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public devicesIdBackupsPost (xAuthToken: string, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: DeviceBackup;  }> {
        const localVarPath = this.basePath + '/devices/{id}/backups'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesIdBackupsPost.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesIdBackupsPost.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DeviceBackup;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DeviceBackup");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Upload data backup
     * @param xAuthToken User authorization token
     * @param id 
     * @param file The uploaded backup file or files
     * @param {*} [options] Override http request options.
     */
    public devicesIdBackupsPut (xAuthToken: string, id: string, file: Buffer, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<DeviceBackup>;  }> {
        const localVarPath = this.basePath + '/devices/{id}/backups'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesIdBackupsPut.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesIdBackupsPut.');
        }

        // verify required parameter 'file' is not null or undefined
        if (file === null || file === undefined) {
            throw new Error('Required parameter file was null or undefined when calling devicesIdBackupsPut.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (file !== undefined) {
            localVarFormParams['file'] = file;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<DeviceBackup>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<DeviceBackup>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete device
     * @param xAuthToken User authorization token
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public devicesIdDelete (xAuthToken: string, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/devices/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesIdDelete.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesIdDelete.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Device status overview
     * @param xAuthToken User authorization token
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public devicesIdGet (xAuthToken: string, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: DeviceStatusOverview;  }> {
        const localVarPath = this.basePath + '/devices/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesIdGet.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesIdGet.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DeviceStatusOverview;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DeviceStatusOverview");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Start device locating
     * @param xAuthToken User authorization token
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public devicesIdLocatePost (xAuthToken: string, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/devices/{id}/locate'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesIdLocatePost.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesIdLocatePost.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Refresh device communication, remove macAesKey
     * @param xAuthToken User authorization token
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public devicesIdRefreshPost (xAuthToken: string, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/devices/{id}/refresh'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesIdRefreshPost.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesIdRefreshPost.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Reset device statistics, action clear-traffic-analysis
     * @param xAuthToken User authorization token
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public devicesIdResetPost (xAuthToken: string, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/devices/{id}/reset'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesIdResetPost.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesIdResetPost.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Restart device, device action reboot
     * @param xAuthToken User authorization token
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public devicesIdRestartPost (xAuthToken: string, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/devices/{id}/restart'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesIdRestartPost.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesIdRestartPost.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Return device statistics
     * @param xAuthToken User authorization token
     * @param id 
     * @param interval 
     * @param {*} [options] Override http request options.
     */
    public devicesIdStatisticsGet (xAuthToken: string, id: string, interval: 'hour' | 'day' | 'month', options: any = {}) : Promise<{ response: http.ClientResponse; body: DeviceStatistics;  }> {
        const localVarPath = this.basePath + '/devices/{id}/statistics'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesIdStatisticsGet.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesIdStatisticsGet.');
        }

        // verify required parameter 'interval' is not null or undefined
        if (interval === null || interval === undefined) {
            throw new Error('Required parameter interval was null or undefined when calling devicesIdStatisticsGet.');
        }

        if (interval !== undefined) {
            localVarQueryParameters['interval'] = ObjectSerializer.serialize(interval, "'hour' | 'day' | 'month'");
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DeviceStatistics;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DeviceStatistics");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Stop device locating
     * @param xAuthToken User authorization token
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public devicesIdUnlocatePost (xAuthToken: string, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/devices/{id}/unlocate'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesIdUnlocatePost.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesIdUnlocatePost.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Return a list of all devices' MAC address (except for ONUs)
     * @param xAuthToken User authorization token
     * @param {*} [options] Override http request options.
     */
    public devicesMacsGet (xAuthToken: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<string>;  }> {
        const localVarPath = this.basePath + '/devices/macs/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesMacsGet.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<string>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<string>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List of all OLTs in network
     * @param xAuthToken User authorization token
     * @param siteId 
     * @param {*} [options] Override http request options.
     */
    public devicesOltsGet (xAuthToken: string, siteId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<DeviceStatusOverview>;  }> {
        const localVarPath = this.basePath + '/devices/olts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesOltsGet.');
        }

        if (siteId !== undefined) {
            localVarQueryParameters['siteId'] = ObjectSerializer.serialize(siteId, "string");
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<DeviceStatusOverview>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<DeviceStatusOverview>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete OLT form UNMS
     * @param xAuthToken User authorization token
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public devicesOltsIdDelete (xAuthToken: string, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/devices/olts/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesOltsIdDelete.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesOltsIdDelete.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Return OLT detail
     * @param xAuthToken User authorization token
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public devicesOltsIdGet (xAuthToken: string, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: OLTStatusDetail;  }> {
        const localVarPath = this.basePath + '/devices/olts/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesOltsIdGet.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesOltsIdGet.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OLTStatusDetail;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "OLTStatusDetail");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List of all OLT ONU profiles
     * @param xAuthToken User authorization token
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public devicesOltsIdProfilesGet (xAuthToken: string, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<OLTONUProfile>;  }> {
        const localVarPath = this.basePath + '/devices/olts/{id}/profiles'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesOltsIdProfilesGet.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesOltsIdProfilesGet.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<OLTONUProfile>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<OLTONUProfile>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create OLT ONU profile
     * @param xAuthToken User authorization token
     * @param id 
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public devicesOltsIdProfilesPost (xAuthToken: string, id: string, body: OLTONUProfile, options: any = {}) : Promise<{ response: http.ClientResponse; body: OLTONUProfile;  }> {
        const localVarPath = this.basePath + '/devices/olts/{id}/profiles'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesOltsIdProfilesPost.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesOltsIdProfilesPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling devicesOltsIdProfilesPost.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "OLTONUProfile")
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OLTONUProfile;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "OLTONUProfile");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete OLT form UNMS
     * @param xAuthToken User authorization token
     * @param id 
     * @param profile 
     * @param {*} [options] Override http request options.
     */
    public devicesOltsIdProfilesProfileDelete (xAuthToken: string, id: string, profile: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/devices/olts/{id}/profiles/{profile}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)))
            .replace('{' + 'profile' + '}', encodeURIComponent(String(profile)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesOltsIdProfilesProfileDelete.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesOltsIdProfilesProfileDelete.');
        }

        // verify required parameter 'profile' is not null or undefined
        if (profile === null || profile === undefined) {
            throw new Error('Required parameter profile was null or undefined when calling devicesOltsIdProfilesProfileDelete.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update OLT ONU profile
     * @param xAuthToken User authorization token
     * @param id 
     * @param profile 
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public devicesOltsIdProfilesProfilePut (xAuthToken: string, id: string, profile: string, body: OLTONUProfile, options: any = {}) : Promise<{ response: http.ClientResponse; body: OLTONUProfile;  }> {
        const localVarPath = this.basePath + '/devices/olts/{id}/profiles/{profile}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)))
            .replace('{' + 'profile' + '}', encodeURIComponent(String(profile)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesOltsIdProfilesProfilePut.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesOltsIdProfilesProfilePut.');
        }

        // verify required parameter 'profile' is not null or undefined
        if (profile === null || profile === undefined) {
            throw new Error('Required parameter profile was null or undefined when calling devicesOltsIdProfilesProfilePut.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling devicesOltsIdProfilesProfilePut.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "OLTONUProfile")
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: OLTONUProfile;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "OLTONUProfile");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary List of all onus in network
     * @param xAuthToken User authorization token
     * @param siteId 
     * @param parentId 
     * @param {*} [options] Override http request options.
     */
    public devicesOnusGet (xAuthToken: string, siteId?: string, parentId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<ONUStatusOverview>;  }> {
        const localVarPath = this.basePath + '/devices/onus';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesOnusGet.');
        }

        if (siteId !== undefined) {
            localVarQueryParameters['siteId'] = ObjectSerializer.serialize(siteId, "string");
        }

        if (parentId !== undefined) {
            localVarQueryParameters['parentId'] = ObjectSerializer.serialize(parentId, "string");
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<ONUStatusOverview>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<ONUStatusOverview>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete ONU GPON password and set status to blocked
     * @param xAuthToken User authorization token
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public devicesOnusIdBlockPost (xAuthToken: string, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/devices/onus/{id}/block'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesOnusIdBlockPost.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesOnusIdBlockPost.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all clients connected to ONU
     * @param xAuthToken User authorization token
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public devicesOnusIdClientsGet (xAuthToken: string, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<ONUClient>;  }> {
        const localVarPath = this.basePath + '/devices/onus/{id}/clients'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesOnusIdClientsGet.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesOnusIdClientsGet.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<ONUClient>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<ONUClient>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete ONU device - call OLT action DELETE_ONU (former forget action)
     * @param xAuthToken User authorization token
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public devicesOnusIdDelete (xAuthToken: string, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/devices/onus/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesOnusIdDelete.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesOnusIdDelete.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Return ONU detail
     * @param xAuthToken User authorization token
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public devicesOnusIdGet (xAuthToken: string, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ONUStatusOverview;  }> {
        const localVarPath = this.basePath + '/devices/onus/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesOnusIdGet.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesOnusIdGet.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ONUStatusOverview;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ONUStatusOverview");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Reset onu data statistics
     * @param xAuthToken 
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public devicesOnusIdResetstatsPost (xAuthToken: string, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/devices/onus/{id}/resetstats'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesOnusIdResetstatsPost.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesOnusIdResetstatsPost.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ServerResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Unblock ONU device - device action UNBLOCK_ONU
     * @param xAuthToken User authorization token
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public devicesOnusIdUnblockPost (xAuthToken: string, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/devices/onus/{id}/unblock'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesOnusIdUnblockPost.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesOnusIdUnblockPost.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Upgrade device
     * @param xAuthToken User authorization token
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public devicesOnusIdUpgradePost (xAuthToken: string, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/devices/onus/{id}/upgrade'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesOnusIdUpgradePost.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling devicesOnusIdUpgradePost.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get devices wireless configuration
     * @param xAuthToken User authorization token
     * @param {*} [options] Override http request options.
     */
    public devicesSsidsGet (xAuthToken: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<any>;  }> {
        const localVarPath = this.basePath + '/devices/ssids';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling devicesSsidsGet.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<any>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<any>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DiscoveryApiApiKeys {
    UserSecurity,
}

export class DiscoveryApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'UserSecurity': new ApiKeyAuth('header', 'x-auth-token'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DiscoveryApiApiKeys, value: string) {
        (this.authentications as any)[DiscoveryApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Batch operation - connects given devices to UNMS
     * @param xAuthToken User authorization token
     * @param payload 
     * @param {*} [options] Override http request options.
     */
    public discoveryConnectPost (xAuthToken: string, payload: Payload, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/discovery/connect';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling discoveryConnectPost.');
        }

        // verify required parameter 'payload' is not null or undefined
        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling discoveryConnectPost.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(payload, "Payload")
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Batch operation - set new credentials of given devices
     * @param xAuthToken User authorization token
     * @param payload 
     * @param {*} [options] Override http request options.
     */
    public discoveryCredentialsPost (xAuthToken: string, payload: Payload, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/discovery/credentials';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling discoveryCredentialsPost.');
        }

        // verify required parameter 'payload' is not null or undefined
        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling discoveryCredentialsPost.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(payload, "Payload")
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete and/or terminate the discovery process
     * @param xAuthToken User authorization token
     * @param {*} [options] Override http request options.
     */
    public discoveryDelete (xAuthToken: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/discovery';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling discoveryDelete.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch result of the last scan
     * @param xAuthToken User authorization token
     * @param {*} [options] Override http request options.
     */
    public discoveryGet (xAuthToken: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: DiscoveryResult;  }> {
        const localVarPath = this.basePath + '/discovery';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling discoveryGet.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DiscoveryResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DiscoveryResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Start new discovery run and terminate any ongoing for current user
     * @param xAuthToken User authorization token
     * @param payload 
     * @param {*} [options] Override http request options.
     */
    public discoveryStartPost (xAuthToken: string, payload: Payload, options: any = {}) : Promise<{ response: http.ClientResponse; body: DiscoveryResult;  }> {
        const localVarPath = this.basePath + '/discovery/start';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling discoveryStartPost.');
        }

        // verify required parameter 'payload' is not null or undefined
        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling discoveryStartPost.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(payload, "Payload")
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DiscoveryResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DiscoveryResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Cancel ongoing discovery task, discovery result is not deleted
     * @param xAuthToken User authorization token
     * @param {*} [options] Override http request options.
     */
    public discoveryStopPost (xAuthToken: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: DiscoveryResult;  }> {
        const localVarPath = this.basePath + '/discovery/stop';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling discoveryStopPost.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DiscoveryResult;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DiscoveryResult");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum FirmwaresApiApiKeys {
    UserSecurity,
}

export class FirmwaresApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'UserSecurity': new ApiKeyAuth('header', 'x-auth-token'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: FirmwaresApiApiKeys, value: string) {
        (this.authentications as any)[FirmwaresApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Batch firmware delete
     * @param xAuthToken User authorization token
     * @param payload 
     * @param {*} [options] Override http request options.
     */
    public firmwaresDeletePost (xAuthToken: string, payload: Array<any>, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Firmware>;  }> {
        const localVarPath = this.basePath + '/firmwares/delete';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling firmwaresDeletePost.');
        }

        // verify required parameter 'payload' is not null or undefined
        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling firmwaresDeletePost.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(payload, "Array<any>")
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Firmware>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Firmware>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch fetch available firmwares
     * @param xAuthToken User authorization token
     * @param {*} [options] Override http request options.
     */
    public firmwaresGet (xAuthToken: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<Firmware>;  }> {
        const localVarPath = this.basePath + '/firmwares';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling firmwaresGet.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Firmware>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Firmware>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Upload new firmware image
     * @param xAuthToken User authorization token
     * @param file The uploaded firmware file or multiple files
     * @param {*} [options] Override http request options.
     */
    public firmwaresPost (xAuthToken: string, file: Buffer, options: any = {}) : Promise<{ response: http.ClientResponse; body: Firmware;  }> {
        const localVarPath = this.basePath + '/firmwares';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling firmwaresPost.');
        }

        // verify required parameter 'file' is not null or undefined
        if (file === null || file === undefined) {
            throw new Error('Required parameter file was null or undefined when calling firmwaresPost.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (file !== undefined) {
            localVarFormParams['file'] = file;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Firmware;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Firmware");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LogsApiApiKeys {
    UserSecurity,
}

export class LogsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'UserSecurity': new ApiKeyAuth('header', 'x-auth-token'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LogsApiApiKeys, value: string) {
        (this.authentications as any)[LogsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary List of all log items (former alerts/events)
     * @param xAuthToken User authorization token
     * @param count 
     * @param page 
     * @param siteId 
     * @param deviceId 
     * @param level 
     * @param period unix timestamp in milliseconds
     * @param query search pattern
     * @param {*} [options] Override http request options.
     */
    public logsGet (xAuthToken: string, count: number, page: number, siteId?: string, deviceId?: string, level?: 'info' | 'warning' | 'error', period?: number, query?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/logs';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling logsGet.');
        }

        // verify required parameter 'count' is not null or undefined
        if (count === null || count === undefined) {
            throw new Error('Required parameter count was null or undefined when calling logsGet.');
        }

        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling logsGet.');
        }

        if (count !== undefined) {
            localVarQueryParameters['count'] = ObjectSerializer.serialize(count, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (siteId !== undefined) {
            localVarQueryParameters['siteId'] = ObjectSerializer.serialize(siteId, "string");
        }

        if (deviceId !== undefined) {
            localVarQueryParameters['deviceId'] = ObjectSerializer.serialize(deviceId, "string");
        }

        if (level !== undefined) {
            localVarQueryParameters['level'] = ObjectSerializer.serialize(level, "'info' | 'warning' | 'error'");
        }

        if (period !== undefined) {
            localVarQueryParameters['period'] = ObjectSerializer.serialize(period, "number");
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Number of unread logItems for logged-in user
     * @param xAuthToken User authorization token
     * @param timestamp unix timestamp in ms
     * @param level 
     * @param {*} [options] Override http request options.
     */
    public logsUnreadGet (xAuthToken: string, timestamp: number, level?: 'error' | 'warning' | 'info', options: any = {}) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/logs/unread';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling logsUnreadGet.');
        }

        // verify required parameter 'timestamp' is not null or undefined
        if (timestamp === null || timestamp === undefined) {
            throw new Error('Required parameter timestamp was null or undefined when calling logsUnreadGet.');
        }

        if (timestamp !== undefined) {
            localVarQueryParameters['timestamp'] = ObjectSerializer.serialize(timestamp, "number");
        }

        if (level !== undefined) {
            localVarQueryParameters['level'] = ObjectSerializer.serialize(level, "'error' | 'warning' | 'info'");
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum NmsApiApiKeys {
    UserSecurity,
}

export class NmsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'UserSecurity': new ApiKeyAuth('header', 'x-auth-token'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: NmsApiApiKeys, value: string) {
        (this.authentications as any)[NmsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Return connect string for unms instance
     * @param xAuthToken User authorization token
     * @param {*} [options] Override http request options.
     */
    public nmsConnectionGet (xAuthToken: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/nms/connection';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling nmsConnectionGet.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Return current codebooks
     * @param {*} [options] Override http request options.
     */
    public nmsEnumsGet (options: any = {}) : Promise<{ response: http.ClientResponse; body: Enums;  }> {
        const localVarPath = this.basePath + '/nms/enums';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Enums;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Enums");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Fetch mail server settings
     * @param xAuthToken User authorization token
     * @param {*} [options] Override http request options.
     */
    public nmsMailserverGet (xAuthToken: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: MailServer;  }> {
        const localVarPath = this.basePath + '/nms/mailserver';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling nmsMailserverGet.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: MailServer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MailServer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update mail server settings
     * @param xAuthToken User authorization token
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public nmsMailserverPut (xAuthToken: string, body: MailServer, options: any = {}) : Promise<{ response: http.ClientResponse; body: MailServer;  }> {
        const localVarPath = this.basePath + '/nms/mailserver';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling nmsMailserverPut.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling nmsMailserverPut.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "MailServer")
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: MailServer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MailServer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary test mail server settings by sending email
     * @param xAuthToken User authorization token
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public nmsMailserverTestPost (xAuthToken: string, body: Body, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/nms/mailserver/test';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling nmsMailserverTestPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling nmsMailserverTestPost.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Body")
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Download data backup
     * @param xAuthToken User authorization token
     * @param retention 
     * @param {*} [options] Override http request options.
     */
    public nmsMaintenanceBackupGet (xAuthToken: string, retention: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: Buffer;  }> {
        const localVarPath = this.basePath + '/nms/maintenance/backup';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling nmsMaintenanceBackupGet.');
        }

        // verify required parameter 'retention' is not null or undefined
        if (retention === null || retention === undefined) {
            throw new Error('Required parameter retention was null or undefined when calling nmsMaintenanceBackupGet.');
        }

        if (retention !== undefined) {
            localVarQueryParameters['retention'] = ObjectSerializer.serialize(retention, "number");
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Buffer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Upload data backup
     * @param xAuthToken User authorization token
     * @param file The uploaded backup file
     * @param {*} [options] Override http request options.
     */
    public nmsMaintenanceBackupPut (xAuthToken: string, file: Buffer, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/nms/maintenance/backup';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling nmsMaintenanceBackupPut.');
        }

        // verify required parameter 'file' is not null or undefined
        if (file === null || file === undefined) {
            throw new Error('Required parameter file was null or undefined when calling nmsMaintenanceBackupPut.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (file !== undefined) {
            localVarFormParams['file'] = file;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Restores uploaded backup file
     * @param xAuthToken User authorization token
     * @param {*} [options] Override http request options.
     */
    public nmsMaintenanceBackupRestoreGet (xAuthToken: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/nms/maintenance/backup/restore';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling nmsMaintenanceBackupRestoreGet.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Download support info
     * @param xAuthToken User authorization token
     * @param {*} [options] Override http request options.
     */
    public nmsMaintenanceSupportinfoGet (xAuthToken: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Buffer;  }> {
        const localVarPath = this.basePath + '/nms/maintenance/supportinfo';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling nmsMaintenanceSupportinfoGet.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Buffer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Refresh NMS certificate
     * @param xAuthToken User authorization token
     * @param {*} [options] Override http request options.
     */
    public nmsRefreshCertificatePut (xAuthToken: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/nms/refresh-certificate';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling nmsRefreshCertificatePut.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Return UNMS server configuration
     * @param {*} [options] Override http request options.
     */
    public nmsServerConfigGet (options: any = {}) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/nms/server-config';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get nms settings
     * @param xAuthToken User authorization token
     * @param {*} [options] Override http request options.
     */
    public nmsSettingsGet (xAuthToken: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: NmsSettings;  }> {
        const localVarPath = this.basePath + '/nms/settings';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling nmsSettingsGet.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: NmsSettings;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "NmsSettings");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updated nms settings
     * @param xAuthToken User authorization token
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public nmsSettingsPut (xAuthToken: string, body: NmsSettings, options: any = {}) : Promise<{ response: http.ClientResponse; body: NmsSettings;  }> {
        const localVarPath = this.basePath + '/nms/settings';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling nmsSettingsPut.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling nmsSettingsPut.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "NmsSettings")
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: NmsSettings;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "NmsSettings");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Return status of UNMS configuration
     * @param {*} [options] Override http request options.
     */
    public nmsSetupGet (options: any = {}) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/nms/setup';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Set up the UNMS instance
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public nmsSetupPost (body: Body, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/nms/setup';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling nmsSetupPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Body")
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get UNMS network statistics
     * @param xAuthToken User authorization token
     * @param interval 
     * @param {*} [options] Override http request options.
     */
    public nmsStatisticsGet (xAuthToken: string, interval: 'hour' | 'day' | 'month', options: any = {}) : Promise<{ response: http.ClientResponse; body: NMSStatistics;  }> {
        const localVarPath = this.basePath + '/nms/statistics';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling nmsStatisticsGet.');
        }

        // verify required parameter 'interval' is not null or undefined
        if (interval === null || interval === undefined) {
            throw new Error('Required parameter interval was null or undefined when calling nmsStatisticsGet.');
        }

        if (interval !== undefined) {
            localVarQueryParameters['interval'] = ObjectSerializer.serialize(interval, "'hour' | 'day' | 'month'");
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: NMSStatistics;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "NMSStatistics");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Various badge-count like values, e.g. unread logs count
     * @param xAuthToken User authorization token
     * @param outagesTimestamp 
     * @param logsTimestamp 
     * @param logsLevel 
     * @param {*} [options] Override http request options.
     */
    public nmsSummaryGet (xAuthToken: string, outagesTimestamp: string, logsTimestamp: string, logsLevel: Array<'error' | 'warning' | 'info'>, options: any = {}) : Promise<{ response: http.ClientResponse; body: NmsSummary;  }> {
        const localVarPath = this.basePath + '/nms/summary';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling nmsSummaryGet.');
        }

        // verify required parameter 'outagesTimestamp' is not null or undefined
        if (outagesTimestamp === null || outagesTimestamp === undefined) {
            throw new Error('Required parameter outagesTimestamp was null or undefined when calling nmsSummaryGet.');
        }

        // verify required parameter 'logsTimestamp' is not null or undefined
        if (logsTimestamp === null || logsTimestamp === undefined) {
            throw new Error('Required parameter logsTimestamp was null or undefined when calling nmsSummaryGet.');
        }

        // verify required parameter 'logsLevel' is not null or undefined
        if (logsLevel === null || logsLevel === undefined) {
            throw new Error('Required parameter logsLevel was null or undefined when calling nmsSummaryGet.');
        }

        if (outagesTimestamp !== undefined) {
            localVarQueryParameters['outagesTimestamp'] = ObjectSerializer.serialize(outagesTimestamp, "string");
        }

        if (logsTimestamp !== undefined) {
            localVarQueryParameters['logsTimestamp'] = ObjectSerializer.serialize(logsTimestamp, "string");
        }

        if (logsLevel !== undefined) {
            localVarQueryParameters['logsLevel'] = ObjectSerializer.serialize(logsLevel, "Array<'error' | 'warning' | 'info'>");
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: NmsSummary;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "NmsSummary");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get nms update status
     * @param xAuthToken User authorization token
     * @param {*} [options] Override http request options.
     */
    public nmsUpdateGet (xAuthToken: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: NmsUpdateStatus;  }> {
        const localVarPath = this.basePath + '/nms/update';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling nmsUpdateGet.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: NmsUpdateStatus;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "NmsUpdateStatus");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Request NMS update
     * @param xAuthToken User authorization token
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public nmsUpdatePut (xAuthToken: string, body: Body, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/nms/update';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling nmsUpdatePut.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling nmsUpdatePut.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Body")
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OutagesApiApiKeys {
    UserSecurity,
}

export class OutagesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'UserSecurity': new ApiKeyAuth('header', 'x-auth-token'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OutagesApiApiKeys, value: string) {
        (this.authentications as any)[OutagesApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary List of all network outages for last month
     * @param xAuthToken User authorization token
     * @param count 
     * @param page 
     * @param siteId 
     * @param deviceId 
     * @param type 
     * @param period unix timestamp in milliseconds
     * @param query search pattern
     * @param {*} [options] Override http request options.
     */
    public outagesGet (xAuthToken: string, count: number, page: number, siteId?: string, deviceId?: string, type?: 'outage' | 'quality', period?: number, query?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/outages';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling outagesGet.');
        }

        // verify required parameter 'count' is not null or undefined
        if (count === null || count === undefined) {
            throw new Error('Required parameter count was null or undefined when calling outagesGet.');
        }

        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling outagesGet.');
        }

        if (count !== undefined) {
            localVarQueryParameters['count'] = ObjectSerializer.serialize(count, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (siteId !== undefined) {
            localVarQueryParameters['siteId'] = ObjectSerializer.serialize(siteId, "string");
        }

        if (deviceId !== undefined) {
            localVarQueryParameters['deviceId'] = ObjectSerializer.serialize(deviceId, "string");
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "'outage' | 'quality'");
        }

        if (period !== undefined) {
            localVarQueryParameters['period'] = ObjectSerializer.serialize(period, "number");
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Number of unread outageItems for logged-in user
     * @param xAuthToken User authorization token
     * @param timestamp unix timestamp in ms
     * @param {*} [options] Override http request options.
     */
    public outagesUnreadGet (xAuthToken: string, timestamp: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/outages/unread';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling outagesUnreadGet.');
        }

        // verify required parameter 'timestamp' is not null or undefined
        if (timestamp === null || timestamp === undefined) {
            throw new Error('Required parameter timestamp was null or undefined when calling outagesUnreadGet.');
        }

        if (timestamp !== undefined) {
            localVarQueryParameters['timestamp'] = ObjectSerializer.serialize(timestamp, "number");
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SitesApiApiKeys {
    UserSecurity,
}

export class SitesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'UserSecurity': new ApiKeyAuth('header', 'x-auth-token'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SitesApiApiKeys, value: string) {
        (this.authentications as any)[SitesApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary List of all sites in network
     * @param xAuthToken User authorization token
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public sitesGet (xAuthToken: string, id?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<SiteOverview>;  }> {
        const localVarPath = this.basePath + '/sites';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling sitesGet.');
        }

        if (id !== undefined) {
            localVarQueryParameters['id'] = ObjectSerializer.serialize(id, "string");
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<SiteOverview>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<SiteOverview>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete site and unauthorize all connected devices
     * @param xAuthToken User authorization token
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public sitesIdDelete (xAuthToken: string, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/sites/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling sitesIdDelete.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling sitesIdDelete.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Return a site's detail
     * @param xAuthToken User authorization token
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public sitesIdGet (xAuthToken: string, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: SiteOverview;  }> {
        const localVarPath = this.basePath + '/sites/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling sitesIdGet.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling sitesIdGet.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SiteOverview;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SiteOverview");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Return all site images sorted by image order
     * @param xAuthToken User authorization token
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public sitesIdImagesGet (xAuthToken: string, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<ImageOverview>;  }> {
        const localVarPath = this.basePath + '/sites/{id}/images'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling sitesIdImagesGet.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling sitesIdImagesGet.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<ImageOverview>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<ImageOverview>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Upload new image and create image thumbnail
     * @param xAuthToken User authorization token
     * @param id 
     * @param file The uploaded image or multiple images
     * @param {*} [options] Override http request options.
     */
    public sitesIdImagesPost (xAuthToken: string, id: string, file: Buffer, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/sites/{id}/images'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling sitesIdImagesPost.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling sitesIdImagesPost.');
        }

        // verify required parameter 'file' is not null or undefined
        if (file === null || file === undefined) {
            throw new Error('Required parameter file was null or undefined when calling sitesIdImagesPost.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (file !== undefined) {
            localVarFormParams['file'] = file;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update site
     * @param xAuthToken User authorization token
     * @param id 
     * @param payload 
     * @param {*} [options] Override http request options.
     */
    public sitesIdPut (xAuthToken: string, id: string, payload: SiteOverview, options: any = {}) : Promise<{ response: http.ClientResponse; body: SiteOverview;  }> {
        const localVarPath = this.basePath + '/sites/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling sitesIdPut.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling sitesIdPut.');
        }

        // verify required parameter 'payload' is not null or undefined
        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling sitesIdPut.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(payload, "SiteOverview")
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SiteOverview;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SiteOverview");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create new site
     * @param xAuthToken User authorization token
     * @param payload 
     * @param {*} [options] Override http request options.
     */
    public sitesPost (xAuthToken: string, payload: Payload, options: any = {}) : Promise<{ response: http.ClientResponse; body: SiteOverview;  }> {
        const localVarPath = this.basePath + '/sites';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling sitesPost.');
        }

        // verify required parameter 'payload' is not null or undefined
        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling sitesPost.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(payload, "Payload")
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SiteOverview;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SiteOverview");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete image
     * @param xAuthToken User authorization token
     * @param imageId 
     * @param siteId 
     * @param {*} [options] Override http request options.
     */
    public sitesSiteIdImagesImageIdDelete (xAuthToken: string, imageId: string, siteId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/sites/{siteId}/images/{imageId}'
            .replace('{' + 'imageId' + '}', encodeURIComponent(String(imageId)))
            .replace('{' + 'siteId' + '}', encodeURIComponent(String(siteId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling sitesSiteIdImagesImageIdDelete.');
        }

        // verify required parameter 'imageId' is not null or undefined
        if (imageId === null || imageId === undefined) {
            throw new Error('Required parameter imageId was null or undefined when calling sitesSiteIdImagesImageIdDelete.');
        }

        // verify required parameter 'siteId' is not null or undefined
        if (siteId === null || siteId === undefined) {
            throw new Error('Required parameter siteId was null or undefined when calling sitesSiteIdImagesImageIdDelete.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Return image file
     * @param xAuthToken User authorization token
     * @param siteId 
     * @param imageId 
     * @param {*} [options] Override http request options.
     */
    public sitesSiteIdImagesImageIdGet (xAuthToken: string, siteId: string, imageId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Buffer;  }> {
        const localVarPath = this.basePath + '/sites/{siteId}/images/{imageId}'
            .replace('{' + 'siteId' + '}', encodeURIComponent(String(siteId)))
            .replace('{' + 'imageId' + '}', encodeURIComponent(String(imageId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling sitesSiteIdImagesImageIdGet.');
        }

        // verify required parameter 'siteId' is not null or undefined
        if (siteId === null || siteId === undefined) {
            throw new Error('Required parameter siteId was null or undefined when calling sitesSiteIdImagesImageIdGet.');
        }

        // verify required parameter 'imageId' is not null or undefined
        if (imageId === null || imageId === undefined) {
            throw new Error('Required parameter imageId was null or undefined when calling sitesSiteIdImagesImageIdGet.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Buffer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Buffer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update image
     * @param xAuthToken User authorization token
     * @param siteId 
     * @param imageId 
     * @param payload 
     * @param {*} [options] Override http request options.
     */
    public sitesSiteIdImagesImageIdPatch (xAuthToken: string, siteId: string, imageId: string, payload: Payload, options: any = {}) : Promise<{ response: http.ClientResponse; body: ImageOverview;  }> {
        const localVarPath = this.basePath + '/sites/{siteId}/images/{imageId}'
            .replace('{' + 'siteId' + '}', encodeURIComponent(String(siteId)))
            .replace('{' + 'imageId' + '}', encodeURIComponent(String(imageId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling sitesSiteIdImagesImageIdPatch.');
        }

        // verify required parameter 'siteId' is not null or undefined
        if (siteId === null || siteId === undefined) {
            throw new Error('Required parameter siteId was null or undefined when calling sitesSiteIdImagesImageIdPatch.');
        }

        // verify required parameter 'imageId' is not null or undefined
        if (imageId === null || imageId === undefined) {
            throw new Error('Required parameter imageId was null or undefined when calling sitesSiteIdImagesImageIdPatch.');
        }

        // verify required parameter 'payload' is not null or undefined
        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling sitesSiteIdImagesImageIdPatch.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(payload, "Payload")
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ImageOverview;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ImageOverview");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Change image order
     * @param xAuthToken User authorization token
     * @param siteId 
     * @param imageId 
     * @param payload 
     * @param {*} [options] Override http request options.
     */
    public sitesSiteIdImagesImageIdReorderPost (xAuthToken: string, siteId: string, imageId: string, payload: Payload, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/sites/{siteId}/images/{imageId}/reorder'
            .replace('{' + 'siteId' + '}', encodeURIComponent(String(siteId)))
            .replace('{' + 'imageId' + '}', encodeURIComponent(String(imageId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling sitesSiteIdImagesImageIdReorderPost.');
        }

        // verify required parameter 'siteId' is not null or undefined
        if (siteId === null || siteId === undefined) {
            throw new Error('Required parameter siteId was null or undefined when calling sitesSiteIdImagesImageIdReorderPost.');
        }

        // verify required parameter 'imageId' is not null or undefined
        if (imageId === null || imageId === undefined) {
            throw new Error('Required parameter imageId was null or undefined when calling sitesSiteIdImagesImageIdReorderPost.');
        }

        // verify required parameter 'payload' is not null or undefined
        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling sitesSiteIdImagesImageIdReorderPost.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(payload, "Payload")
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Rotate the image 90 degrees to left
     * @param xAuthToken User authorization token
     * @param siteId 
     * @param imageId 
     * @param {*} [options] Override http request options.
     */
    public sitesSiteIdImagesImageIdRotateleftPost (xAuthToken: string, siteId: string, imageId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/sites/{siteId}/images/{imageId}/rotateleft'
            .replace('{' + 'siteId' + '}', encodeURIComponent(String(siteId)))
            .replace('{' + 'imageId' + '}', encodeURIComponent(String(imageId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling sitesSiteIdImagesImageIdRotateleftPost.');
        }

        // verify required parameter 'siteId' is not null or undefined
        if (siteId === null || siteId === undefined) {
            throw new Error('Required parameter siteId was null or undefined when calling sitesSiteIdImagesImageIdRotateleftPost.');
        }

        // verify required parameter 'imageId' is not null or undefined
        if (imageId === null || imageId === undefined) {
            throw new Error('Required parameter imageId was null or undefined when calling sitesSiteIdImagesImageIdRotateleftPost.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Rotate the image 90 degrees to right
     * @param xAuthToken User authorization token
     * @param siteId 
     * @param imageId 
     * @param {*} [options] Override http request options.
     */
    public sitesSiteIdImagesImageIdRotaterightPost (xAuthToken: string, siteId: string, imageId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/sites/{siteId}/images/{imageId}/rotateright'
            .replace('{' + 'siteId' + '}', encodeURIComponent(String(siteId)))
            .replace('{' + 'imageId' + '}', encodeURIComponent(String(imageId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling sitesSiteIdImagesImageIdRotaterightPost.');
        }

        // verify required parameter 'siteId' is not null or undefined
        if (siteId === null || siteId === undefined) {
            throw new Error('Required parameter siteId was null or undefined when calling sitesSiteIdImagesImageIdRotaterightPost.');
        }

        // verify required parameter 'imageId' is not null or undefined
        if (imageId === null || imageId === undefined) {
            throw new Error('Required parameter imageId was null or undefined when calling sitesSiteIdImagesImageIdRotaterightPost.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TasksApiApiKeys {
    UserSecurity,
}

export class TasksApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'UserSecurity': new ApiKeyAuth('header', 'x-auth-token'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TasksApiApiKeys, value: string) {
        (this.authentications as any)[TasksApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary List all tasks
     * @param xAuthToken User authorization token
     * @param count 
     * @param page 
     * @param status 
     * @param period unix timestamp in milliseconds
     * @param {*} [options] Override http request options.
     */
    public tasksGet (xAuthToken: string, count: number, page: number, status?: string, period?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/tasks';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling tasksGet.');
        }

        // verify required parameter 'count' is not null or undefined
        if (count === null || count === undefined) {
            throw new Error('Required parameter count was null or undefined when calling tasksGet.');
        }

        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling tasksGet.');
        }

        if (count !== undefined) {
            localVarQueryParameters['count'] = ObjectSerializer.serialize(count, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "string");
        }

        if (period !== undefined) {
            localVarQueryParameters['period'] = ObjectSerializer.serialize(period, "number");
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Cancel a task
     * @param xAuthToken User authorization token
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public tasksIdDelete (xAuthToken: string, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/tasks/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling tasksIdDelete.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling tasksIdDelete.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns a mass upgrade task inner task items
     * @param xAuthToken User authorization token
     * @param id 
     * @param count 
     * @param page 
     * @param {*} [options] Override http request options.
     */
    public tasksIdGet (xAuthToken: string, id: string, count: number, page: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/tasks/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling tasksIdGet.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling tasksIdGet.');
        }

        // verify required parameter 'count' is not null or undefined
        if (count === null || count === undefined) {
            throw new Error('Required parameter count was null or undefined when calling tasksIdGet.');
        }

        // verify required parameter 'page' is not null or undefined
        if (page === null || page === undefined) {
            throw new Error('Required parameter page was null or undefined when calling tasksIdGet.');
        }

        if (count !== undefined) {
            localVarQueryParameters['count'] = ObjectSerializer.serialize(count, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Return number of tasks in progress
     * @param xAuthToken User authorization token
     * @param {*} [options] Override http request options.
     */
    public tasksInProgressGet (xAuthToken: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const localVarPath = this.basePath + '/tasks/in-progress';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling tasksInProgressGet.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UserApiApiKeys {
    UserSecurity,
}

export class UserApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'UserSecurity': new ApiKeyAuth('header', 'x-auth-token'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UserApiApiKeys, value: string) {
        (this.authentications as any)[UserApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Get the authenticated user
     * @param xAuthToken User authorization token
     * @param {*} [options] Override http request options.
     */
    public userGet (xAuthToken: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: User;  }> {
        const localVarPath = this.basePath + '/user';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling userGet.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Login
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public userLoginPost (body: Login, options: any = {}) : Promise<{ response: http.ClientResponse; body: User;  }> {
        const localVarPath = this.basePath + '/user/login';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling userLoginPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Login")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Two Factor Authentication login step 2
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public userLoginTotpauthPost (body: Body, options: any = {}) : Promise<{ response: http.ClientResponse; body: User;  }> {
        const localVarPath = this.basePath + '/user/login/totpauth';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling userLoginTotpauthPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Body")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Logout
     * @param xAuthToken User authorization token
     * @param {*} [options] Override http request options.
     */
    public userLogoutPost (xAuthToken: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/user/logout';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling userLogoutPost.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Login
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public userPasswordRequestresetPost (body: Body, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/user/password/requestreset';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling userPasswordRequestresetPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Body")
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Login
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public userPasswordResetPost (body: Body, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/user/password/reset';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling userPasswordResetPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Body")
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the authenticated user profile
     * @param xAuthToken User authorization token
     * @param {*} [options] Override http request options.
     */
    public userProfileGet (xAuthToken: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: UserProfile;  }> {
        const localVarPath = this.basePath + '/user/profile';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling userProfileGet.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserProfile;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserProfile");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates authenticated user
     * @param xAuthToken User authorization token
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public userProfilePut (xAuthToken: string, body: UserProfile, options: any = {}) : Promise<{ response: http.ClientResponse; body: UserProfile;  }> {
        const localVarPath = this.basePath + '/user/profile';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling userProfilePut.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling userProfilePut.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "UserProfile")
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserProfile;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserProfile");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates authenticated user
     * @param xAuthToken User authorization token
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public userPut (xAuthToken: string, body: Body, options: any = {}) : Promise<{ response: http.ClientResponse; body: User;  }> {
        const localVarPath = this.basePath + '/user';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling userPut.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling userPut.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Body")
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets new information for two factor authentication
     * @param xAuthToken User authorization token
     * @param {*} [options] Override http request options.
     */
    public userTotpauthGet (xAuthToken: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: TwoFactorSecret;  }> {
        const localVarPath = this.basePath + '/user/totpauth';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling userTotpauthGet.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TwoFactorSecret;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TwoFactorSecret");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Sets two factor authentication for user
     * @param xAuthToken User authorization token
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public userTotpauthPut (xAuthToken: string, body: Body, options: any = {}) : Promise<{ response: http.ClientResponse; body: User;  }> {
        const localVarPath = this.basePath + '/user/totpauth';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling userTotpauthPut.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling userTotpauthPut.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Body")
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UsersApiApiKeys {
    UserSecurity,
}

export class UsersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'UserSecurity': new ApiKeyAuth('header', 'x-auth-token'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UsersApiApiKeys, value: string) {
        (this.authentications as any)[UsersApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Return list of users
     * @param xAuthToken User authorization token
     * @param {*} [options] Override http request options.
     */
    public usersGet (xAuthToken: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<User>;  }> {
        const localVarPath = this.basePath + '/users';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling usersGet.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<User>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<User>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete user
     * @param xAuthToken User authorization token
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public usersIdDelete (xAuthToken: string, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/users/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling usersIdDelete.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling usersIdDelete.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates user
     * @param xAuthToken User authorization token
     * @param id 
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public usersIdPut (xAuthToken: string, id: string, body: User, options: any = {}) : Promise<{ response: http.ClientResponse; body: User;  }> {
        const localVarPath = this.basePath + '/users/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling usersIdPut.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling usersIdPut.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling usersIdPut.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "User")
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Reinvites user by email
     * @param xAuthToken User authorization token
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public usersIdReinvitePost (xAuthToken: string, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Status;  }> {
        const localVarPath = this.basePath + '/users/{id}/reinvite'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling usersIdReinvitePost.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling usersIdReinvitePost.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Status;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Status");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Creates new user
     * @param xAuthToken User authorization token
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public usersPost (xAuthToken: string, body: Body, options: any = {}) : Promise<{ response: http.ClientResponse; body: User;  }> {
        const localVarPath = this.basePath + '/users';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'xAuthToken' is not null or undefined
        if (xAuthToken === null || xAuthToken === undefined) {
            throw new Error('Required parameter xAuthToken was null or undefined when calling usersPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling usersPost.');
        }

        localVarHeaderParams['x-auth-token'] = ObjectSerializer.serialize(xAuthToken, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Body")
        };

        this.authentications.UserSecurity.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
